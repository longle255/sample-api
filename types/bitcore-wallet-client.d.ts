export = index;
declare class index {
    static getRawTx(txp: any): any;
    static parseSecret(secret: any): any;
    static privateKeyEncryptionOpts: {
        iter: number;
    };
    static signTxProposalFromAirGapped(key: any, txp: any, unencryptedPkr: any, m: any, n: any, opts: any): any;
    static signTxp(txp: any, derivedXPrivKey: any): any;
    constructor(opts: any);
    doNotVerifyPayPro: any;
    timeout: any;
    logLevel: any;
    supportStaffWalletId: any;
    request: any;
    addAccess(opts: any, cb: any): void;
    addListener(type: any, listener: any): any;
    broadcastRawTx(opts: any, cb: any): void;
    broadcastTxProposal(txp: any, cb: any): void;
    buildTxFromPrivateKey(privateKey: any, destinationAddress: any, opts: any, cb: any): void;
    canSign(): any;
    checkPassword(password: any): any;
    clearMnemonic(): any;
    public createAddress(opts: any, cb: any): any;
    createTxProposal(opts: any, cb: any): void;
    createWallet(walletName: any, copayerName: any, m: any, n: any, opts: any, cb: any): any;
    createWalletFromOldCopay(username: any, password: any, blob: any, cb: any): any;
    decryptBIP38PrivateKey(encryptedPrivateKeyBase58: any, passphrase: any, opts: any, cb: any): any;
    decryptPrivateKey(password: any): any;
    dispose(cb: any): void;
    editTxNote(opts: any, cb: any): void;
    emit(type: any, args: any): any;
    encryptPrivateKey(password: any, opts: any): void;
    export(): any;
    eventNames(): any;
    fetchPayPro(opts: any, cb: any): void;
    getBalance(opts: any, cb: any): any;
    getBalanceFromPrivateKey(privateKey: any, coin: any, cb: any): void;
    getFeeLevels(coin: any, network: any, cb: any): void;
    getFiatRate(opts: any, cb: any): void;
    getKeys(password: any): any;
    getMainAddresses(opts: any, cb: any): void;
    getMaxListeners(): any;
    getMnemonic(): any;
    getNotifications(opts: any, cb: any): void;
    getPayPro(txp: any, cb: any): any;
    getPreferences(cb: any): void;
    getPrivKeyExternalSourceName(): any;
    getSendMaxInfo(opts: any, cb: any): void;
    getStatus(opts: any, cb: any): void;
    getStatusByIdentifier(opts: any, cb: any): void;
    getTx(id: any, cb: any): void;
    getTxHistory(opts: any, cb: any): void;
    getTxNote(opts: any, cb: any): void;
    getTxNotes(opts: any, cb: any): void;
    getTxProposals(opts: any, cb: any): void;
    getUtxos(opts: any, cb: any): void;
    getVersion(cb: any): void;
    getWalletIdsFromOldCopay(username: any, password: any, blob: any): any;
    import(credential: string): void;
    importFromExtendedPrivateKey(xPrivKey: any, opts: any, cb: any): any;
    importFromExtendedPublicKey(xPubKey: any, source: any, entropySourceHex: any, opts: any, cb: any, ...args: any[]): any;
    importFromMnemonic(words: any, opts: any, cb: any): any;
    initNotifications(cb: any): void;
    initialize(opts: any, cb: any): any;
    isComplete(): any;
    isPrivKeyEncrypted(): any;
    isPrivKeyExternal(): any;
    joinWallet(secret: any, copayerName: any, opts: any, cb: any): any;
    listenerCount(type: any): any;
    listeners(type: any): any;
    mnemonicHasPassphrase(): any;
    off(type: any, listener: any): any;
    on(type: any, listener: any): any;
    once(type: any, listener: any): any;
    openWallet(cb: any): any;
    prependListener(type: any, listener: any): any;
    prependOnceListener(type: any, listener: any): any;
    publishTxProposal(opts: any, cb: any): void;
    pushNotificationsSubscribe(opts: any, cb: any): void;
    pushNotificationsUnsubscribe(token: any, cb: any): void;
    rawListeners(type: any): any;
    recreateWallet(cb: any): void;
    rejectTxProposal(txp: any, reason: any, cb: any): void;
    removeAllListeners(type: any, ...args: any[]): any;
    removeListener(type: any, listener: any): any;
    removeTxProposal(txp: any, cb: any): void;
    savePreferences(preferences: any, cb: any): void;
    seedFromExtendedPrivateKey(xPrivKey: any, opts: any): void;
    seedFromExtendedPublicKey(xPubKey: any, source: any, entropySourceHex: any, opts: any): void;
    seedFromMnemonic(words: any, opts: any): void;
    seedFromRandom(opts: any, ...args: any[]): void;
    seedFromRandomWithMnemonic(opts: any, ...args: any[]): void;
    setMaxListeners(n: any): any;
    setNotificationsInterval(notificationIntervalSeconds: any): void;
    signTxProposal(txp: any, password: any, cb: any): any;
    signTxProposalFromAirGapped(txp: any, encryptedPkr: any, m: any, n: any, password: any): any;
    startScan(opts: any, cb: any): void;
    txConfirmationSubscribe(opts: any, cb: any): void;
    txConfirmationUnsubscribe(txid: any, cb: any): void;
    validateKeyDerivation(opts: any, cb: any): any;
}
declare namespace index {
    namespace Bitcore {
        class Address {
            static PayToPublicKeyHash: string;
            static PayToScriptHash: string;
            static createMultisig(publicKeys: any, threshold: any, network: any, nestedWitness: any): any;
            static fromBuffer(buffer: any, network: any, type: any): any;
            static fromObject(obj: any): any;
            static fromPublicKey(data: any, network: any): any;
            static fromPublicKeyHash(hash: any, network: any): any;
            static fromScript(script: any, network: any): any;
            static fromScriptHash(hash: any, network: any): any;
            static fromString(str: any, network: any, type: any): any;
            static getValidationError(data: any, network: any, type: any): any;
            static isValid(data: any, network: any, type: any): any;
            static payingTo(script: any, network: any): any;
            constructor(data: any, network: any, type: any);
            inspect(): any;
            isPayToPublicKeyHash(): any;
            isPayToScriptHash(): any;
            toBuffer(): any;
            toJSON(): any;
            toObject(): any;
        }
        class Block {
            static MAX_BLOCK_SIZE: number;
            static Values: {
                NULL_HASH: Buffer;
                START_OF_BLOCK: number;
            };
            static fromBuffer(buf: any): any;
            static fromBufferReader(br: any): any;
            static fromObject(obj: any): any;
            static fromRawBlock(data: any): any;
            static fromString(str: any): any;
            constructor(arg: any);
            getMerkleRoot(): any;
            getMerkleTree(): any;
            getTransactionHashes(): any;
            inspect(): any;
            toBuffer(): any;
            toBufferWriter(bw: any): any;
            toJSON(): any;
            toObject(): any;
            validMerkleRoot(): any;
        }
        namespace Block {
            class BlockHeader {
                static Constants: {
                    LARGEST_HASH: any;
                    MAX_TIME_OFFSET: any;
                    START_OF_HEADER: any;
                };
                static fromBuffer(buf: any): any;
                static fromBufferReader(br: any): any;
                static fromObject(obj: any): any;
                static fromRawBlock(data: any): any;
                static fromString(str: any): any;
                constructor(arg: any);
                version: any;
                prevHash: any;
                merkleRoot: any;
                time: any;
                timestamp: any;
                bits: any;
                nonce: any;
                getDifficulty(): any;
                getTargetDifficulty(bits: any): any;
                inspect(): any;
                toBuffer(): any;
                toBufferWriter(bw: any): any;
                toJSON(): any;
                toObject(): any;
                validProofOfWork(): any;
                validTimestamp(): any;
            }
            class MerkleBlock {
                static fromBuffer(buf: any): any;
                static fromBufferReader(br: any): any;
                static fromObject(obj: any): any;
                constructor(arg: any);
                filterdTxsHash(): any;
                hasTransaction(tx: any): any;
                toBuffer(): any;
                toBufferWriter(bw: any): any;
                toJSON(): any;
                toObject(): any;
                validMerkleTree(): any;
            }
        }
        class BlockHeader {
            static Constants: {
                LARGEST_HASH: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                MAX_TIME_OFFSET: number;
                START_OF_HEADER: number;
            };
            static fromBuffer(buf: any): any;
            static fromBufferReader(br: any): any;
            static fromObject(obj: any): any;
            static fromRawBlock(data: any): any;
            static fromString(str: any): any;
            constructor(arg: any);
            version: any;
            prevHash: any;
            merkleRoot: any;
            time: any;
            timestamp: any;
            bits: any;
            nonce: any;
            getDifficulty(): any;
            getTargetDifficulty(bits: any): any;
            inspect(): any;
            toBuffer(): any;
            toBufferWriter(bw: any): any;
            toJSON(): any;
            toObject(): any;
            validProofOfWork(): any;
            validTimestamp(): any;
        }
        class HDPrivateKey {
            static ChainCodeEnd: number;
            static ChainCodeSize: number;
            static ChainCodeStart: number;
            static CheckSumSize: number;
            static ChecksumEnd: number;
            static ChecksumStart: number;
            static ChildIndexEnd: number;
            static ChildIndexSize: number;
            static ChildIndexStart: number;
            static DataLength: number;
            static DefaultChildIndex: number;
            static DefaultDepth: number;
            static DefaultFingerprint: number;
            static DepthEnd: number;
            static DepthSize: number;
            static DepthStart: number;
            static Hardened: number;
            static MaxIndex: number;
            static ParentFingerPrintEnd: number;
            static ParentFingerPrintSize: number;
            static ParentFingerPrintStart: number;
            static PrivateKeyEnd: number;
            static PrivateKeySize: number;
            static PrivateKeyStart: number;
            static RootElementAlias: string[];
            static SerializedByteSize: number;
            static VersionEnd: number;
            static VersionSize: number;
            static VersionStart: number;
            static fromBuffer(arg: any): any;
            static fromObject(arg: any): any;
            static fromSeed(hexa: any, network: any): any;
            static fromString(arg: any): any;
            static getSerializedError(data: any, network: any): any;
            static isValidPath(arg: any, hardened: any): any;
            static isValidSerialized(data: any, network: any): any;
            constructor(arg: any);
            derive(arg: any, hardened: any): any;
            deriveChild(arg: any, hardened: any): any;
            deriveNonCompliantChild(arg: any, hardened: any): any;
            inspect(): any;
            toBuffer(): any;
            toJSON(): any;
            toObject(): any;
        }
        class HDPublicKey {
            static ChainCodeEnd: number;
            static ChainCodeSize: number;
            static ChainCodeStart: number;
            static CheckSumSize: number;
            static ChecksumEnd: number;
            static ChecksumStart: number;
            static ChildIndexEnd: number;
            static ChildIndexSize: number;
            static ChildIndexStart: number;
            static DataSize: number;
            static DepthEnd: number;
            static DepthSize: number;
            static DepthStart: number;
            static Hardened: number;
            static ParentFingerPrintEnd: number;
            static ParentFingerPrintSize: number;
            static ParentFingerPrintStart: number;
            static PublicKeyEnd: number;
            static PublicKeySize: number;
            static PublicKeyStart: number;
            static RootElementAlias: string[];
            static SerializedByteSize: number;
            static VersionEnd: number;
            static VersionSize: number;
            static VersionStart: number;
            static fromBuffer(arg: any): any;
            static fromObject(arg: any): any;
            static fromString(arg: any): any;
            static getSerializedError(data: any, network: any): any;
            static isValidPath(arg: any): any;
            static isValidSerialized(data: any, network: any): any;
            constructor(arg: any);
            derive(arg: any, hardened: any): any;
            deriveChild(arg: any, hardened: any): any;
            inspect(): any;
            toBuffer(): any;
            toJSON(): any;
            toObject(): any;
        }
        class MerkleBlock {
            static fromBuffer(buf: any): any;
            static fromBufferReader(br: any): any;
            static fromObject(obj: any): any;
            constructor(arg: any);
            filterdTxsHash(): any;
            hasTransaction(tx: any): any;
            toBuffer(): any;
            toBufferWriter(bw: any): any;
            toJSON(): any;
            toObject(): any;
            validMerkleTree(): any;
        }
        class Message {
            static MAGIC_BYTES: Buffer;
            static fromJSON(json: any): any;
            static fromString(str: any): any;
            constructor(message: any);
            message: any;
            inspect(): any;
            magicHash(): any;
            sign(privateKey: any): any;
            toJSON(): any;
            toObject(): any;
            verify(bitcoinAddress: any, signatureString: any): any;
        }
        namespace Networks {
            function add(data: any): any;
            const defaultNetwork: {
                alias: string;
                dnsSeeds: any[];
                name: string;
                networkMagic: Buffer;
                port: number;
                privatekey: number;
                pubkeyhash: number;
                scripthash: number;
                xprivkey: number;
                xpubkey: number;
            };
            function disableRegtest(): void;
            function enableRegtest(): void;
            function get(arg: any, keys: any): any;
            const livenet: {
                alias: string;
                dnsSeeds: any[];
                name: string;
                networkMagic: Buffer;
                port: number;
                privatekey: number;
                pubkeyhash: number;
                scripthash: number;
                xprivkey: number;
                xpubkey: number;
            };
            const mainnet: {
                alias: string;
                dnsSeeds: any[];
                name: string;
                networkMagic: Buffer;
                port: number;
                privatekey: number;
                pubkeyhash: number;
                scripthash: number;
                xprivkey: number;
                xpubkey: number;
            };
            const regtest: {
                alias: string;
                dnsSeeds: any[];
                name: string;
                networkMagic: Buffer;
                port: number;
                privatekey: number;
                pubkeyhash: number;
                scripthash: number;
                xprivkey: number;
                xpubkey: number;
            };
            function remove(network: any): void;
            const testnet: {
                alias: string;
                dnsSeeds: any[];
                name: string;
                networkMagic: Buffer;
                port: number;
                privatekey: number;
                pubkeyhash: number;
                scripthash: number;
                xprivkey: number;
                xpubkey: number;
            };
        }
        class Opcode {
            static OP_0: number;
            static OP_0NOTEQUAL: number;
            static OP_1: number;
            static OP_10: number;
            static OP_11: number;
            static OP_12: number;
            static OP_13: number;
            static OP_14: number;
            static OP_15: number;
            static OP_16: number;
            static OP_1ADD: number;
            static OP_1NEGATE: number;
            static OP_1SUB: number;
            static OP_2: number;
            static OP_2DIV: number;
            static OP_2DROP: number;
            static OP_2DUP: number;
            static OP_2MUL: number;
            static OP_2OVER: number;
            static OP_2ROT: number;
            static OP_2SWAP: number;
            static OP_3: number;
            static OP_3DUP: number;
            static OP_4: number;
            static OP_5: number;
            static OP_6: number;
            static OP_7: number;
            static OP_8: number;
            static OP_9: number;
            static OP_ABS: number;
            static OP_ADD: number;
            static OP_AND: number;
            static OP_BOOLAND: number;
            static OP_BOOLOR: number;
            static OP_CAT: number;
            static OP_CHECKLOCKTIMEVERIFY: number;
            static OP_CHECKMULTISIG: number;
            static OP_CHECKMULTISIGVERIFY: number;
            static OP_CHECKSEQUENCEVERIFY: number;
            static OP_CHECKSIG: number;
            static OP_CHECKSIGVERIFY: number;
            static OP_CODESEPARATOR: number;
            static OP_DEPTH: number;
            static OP_DIV: number;
            static OP_DROP: number;
            static OP_DUP: number;
            static OP_ELSE: number;
            static OP_ENDIF: number;
            static OP_EQUAL: number;
            static OP_EQUALVERIFY: number;
            static OP_FALSE: number;
            static OP_FROMALTSTACK: number;
            static OP_GREATERTHAN: number;
            static OP_GREATERTHANOREQUAL: number;
            static OP_HASH160: number;
            static OP_HASH256: number;
            static OP_IF: number;
            static OP_IFDUP: number;
            static OP_INVALIDOPCODE: number;
            static OP_INVERT: number;
            static OP_LEFT: number;
            static OP_LESSTHAN: number;
            static OP_LESSTHANOREQUAL: number;
            static OP_LSHIFT: number;
            static OP_MAX: number;
            static OP_MIN: number;
            static OP_MOD: number;
            static OP_MUL: number;
            static OP_NEGATE: number;
            static OP_NIP: number;
            static OP_NOP: number;
            static OP_NOP1: number;
            static OP_NOP10: number;
            static OP_NOP2: number;
            static OP_NOP3: number;
            static OP_NOP4: number;
            static OP_NOP5: number;
            static OP_NOP6: number;
            static OP_NOP7: number;
            static OP_NOP8: number;
            static OP_NOP9: number;
            static OP_NOT: number;
            static OP_NOTIF: number;
            static OP_NUMEQUAL: number;
            static OP_NUMEQUALVERIFY: number;
            static OP_NUMNOTEQUAL: number;
            static OP_OR: number;
            static OP_OVER: number;
            static OP_PICK: number;
            static OP_PUBKEY: number;
            static OP_PUBKEYHASH: number;
            static OP_PUSHDATA1: number;
            static OP_PUSHDATA2: number;
            static OP_PUSHDATA4: number;
            static OP_RESERVED: number;
            static OP_RESERVED1: number;
            static OP_RESERVED2: number;
            static OP_RETURN: number;
            static OP_RIGHT: number;
            static OP_RIPEMD160: number;
            static OP_ROLL: number;
            static OP_ROT: number;
            static OP_RSHIFT: number;
            static OP_SHA1: number;
            static OP_SHA256: number;
            static OP_SIZE: number;
            static OP_SUB: number;
            static OP_SUBSTR: number;
            static OP_SWAP: number;
            static OP_TOALTSTACK: number;
            static OP_TRUE: number;
            static OP_TUCK: number;
            static OP_VER: number;
            static OP_VERIF: number;
            static OP_VERIFY: number;
            static OP_VERNOTIF: number;
            static OP_WITHIN: number;
            static OP_XOR: number;
            static fromBuffer(buf: any): any;
            static fromNumber(num: any): any;
            static fromString(str: any): any;
            static isSmallIntOp(opcode: any): any;
            static map: {
                OP_0: number;
                OP_0NOTEQUAL: number;
                OP_1: number;
                OP_10: number;
                OP_11: number;
                OP_12: number;
                OP_13: number;
                OP_14: number;
                OP_15: number;
                OP_16: number;
                OP_1ADD: number;
                OP_1NEGATE: number;
                OP_1SUB: number;
                OP_2: number;
                OP_2DIV: number;
                OP_2DROP: number;
                OP_2DUP: number;
                OP_2MUL: number;
                OP_2OVER: number;
                OP_2ROT: number;
                OP_2SWAP: number;
                OP_3: number;
                OP_3DUP: number;
                OP_4: number;
                OP_5: number;
                OP_6: number;
                OP_7: number;
                OP_8: number;
                OP_9: number;
                OP_ABS: number;
                OP_ADD: number;
                OP_AND: number;
                OP_BOOLAND: number;
                OP_BOOLOR: number;
                OP_CAT: number;
                OP_CHECKLOCKTIMEVERIFY: number;
                OP_CHECKMULTISIG: number;
                OP_CHECKMULTISIGVERIFY: number;
                OP_CHECKSEQUENCEVERIFY: number;
                OP_CHECKSIG: number;
                OP_CHECKSIGVERIFY: number;
                OP_CODESEPARATOR: number;
                OP_DEPTH: number;
                OP_DIV: number;
                OP_DROP: number;
                OP_DUP: number;
                OP_ELSE: number;
                OP_ENDIF: number;
                OP_EQUAL: number;
                OP_EQUALVERIFY: number;
                OP_FALSE: number;
                OP_FROMALTSTACK: number;
                OP_GREATERTHAN: number;
                OP_GREATERTHANOREQUAL: number;
                OP_HASH160: number;
                OP_HASH256: number;
                OP_IF: number;
                OP_IFDUP: number;
                OP_INVALIDOPCODE: number;
                OP_INVERT: number;
                OP_LEFT: number;
                OP_LESSTHAN: number;
                OP_LESSTHANOREQUAL: number;
                OP_LSHIFT: number;
                OP_MAX: number;
                OP_MIN: number;
                OP_MOD: number;
                OP_MUL: number;
                OP_NEGATE: number;
                OP_NIP: number;
                OP_NOP: number;
                OP_NOP1: number;
                OP_NOP10: number;
                OP_NOP2: number;
                OP_NOP3: number;
                OP_NOP4: number;
                OP_NOP5: number;
                OP_NOP6: number;
                OP_NOP7: number;
                OP_NOP8: number;
                OP_NOP9: number;
                OP_NOT: number;
                OP_NOTIF: number;
                OP_NUMEQUAL: number;
                OP_NUMEQUALVERIFY: number;
                OP_NUMNOTEQUAL: number;
                OP_OR: number;
                OP_OVER: number;
                OP_PICK: number;
                OP_PUBKEY: number;
                OP_PUBKEYHASH: number;
                OP_PUSHDATA1: number;
                OP_PUSHDATA2: number;
                OP_PUSHDATA4: number;
                OP_RESERVED: number;
                OP_RESERVED1: number;
                OP_RESERVED2: number;
                OP_RETURN: number;
                OP_RIGHT: number;
                OP_RIPEMD160: number;
                OP_ROLL: number;
                OP_ROT: number;
                OP_RSHIFT: number;
                OP_SHA1: number;
                OP_SHA256: number;
                OP_SIZE: number;
                OP_SUB: number;
                OP_SUBSTR: number;
                OP_SWAP: number;
                OP_TOALTSTACK: number;
                OP_TRUE: number;
                OP_TUCK: number;
                OP_VER: number;
                OP_VERIF: number;
                OP_VERIFY: number;
                OP_VERNOTIF: number;
                OP_WITHIN: number;
                OP_XOR: number;
            };
            static reverseMap: string[];
            static smallInt(n: any): any;
            constructor(num: any);
            inspect(): any;
            toBuffer(): any;
            toHex(): any;
            toNumber(): any;
        }
        class PrivateKey {
            static fromBuffer(arg: any, network: any): any;
            static fromObject(obj: any): any;
            static fromRandom(network: any): any;
            static fromString(str: any): any;
            static fromWIF(str: any): any;
            static getValidationError(data: any, network: any): any;
            static isValid(data: any, network: any): any;
            constructor(data: any, network: any);
            inspect(): any;
            toAddress(network: any): any;
            toBigNumber(): any;
            toBuffer(): any;
            toBufferNoPadding(): any;
            toJSON(): any;
            toObject(): any;
            toPublicKey(): any;
            toWIF(): any;
        }
        class PublicKey {
            static fromBuffer(buf: any, strict: any): any;
            static fromDER(buf: any, strict: any): any;
            static fromPoint(point: any, compressed: any): any;
            static fromPrivateKey(privkey: any): any;
            static fromString(str: any, encoding: any): any;
            static fromX(odd: any, x: any): any;
            static getValidationError(data: any): any;
            static isValid(data: any): any;
            constructor(data: any, extra: any);
            inspect(): any;
            toAddress(network: any): any;
            toBuffer(): any;
            toDER(): any;
            toJSON(): any;
            toObject(): any;
        }
        class Script {
            static OP_RETURN_STANDARD_SIZE: number;
            static buildDataOut(data: any, encoding: any): any;
            static buildMultisigIn(pubkeys: any, threshold: any, signatures: any, opts: any): any;
            static buildMultisigOut(publicKeys: any, threshold: any, opts: any): any;
            static buildP2SHMultisigIn(pubkeys: any, threshold: any, signatures: any, opts: any): any;
            static buildPublicKeyHashIn(publicKey: any, signature: any, sigtype: any): any;
            static buildPublicKeyHashOut(to: any): any;
            static buildPublicKeyIn(signature: any, sigtype: any): any;
            static buildPublicKeyOut(pubkey: any): any;
            static buildScriptHashOut(script: any): any;
            static buildWitnessMultisigOutFromScript(script: any): any;
            static empty(): any;
            static fromASM(str: any): any;
            static fromAddress(address: any): any;
            static fromBuffer(buffer: any): any;
            static fromHex(str: any): any;
            static fromString(str: any): any;
            static types: {
                DATA_OUT: string;
                MULTISIG_IN: string;
                MULTISIG_OUT: string;
                PUBKEYHASH_IN: string;
                PUBKEYHASH_OUT: string;
                PUBKEY_IN: string;
                PUBKEY_OUT: string;
                SCRIPTHASH_IN: string;
                SCRIPTHASH_OUT: string;
                UNKNOWN: string;
            };
            constructor(from: any);
            chunks: any;
            add(obj: any): any;
            checkMinimalPush(i: any): any;
            classify(): any;
            classifyInput(): any;
            classifyOutput(): any;
            equals(script: any): any;
            findAndDelete(script: any): any;
            getAddressInfo(opts: any): any;
            getData(): any;
            getPublicKey(): any;
            getPublicKeyHash(): any;
            getSignatureOperationsCount(accurate: any): any;
            hasCodeseparators(): any;
            inspect(): any;
            isDataOut(): any;
            isMultisigIn(): any;
            isMultisigOut(): any;
            isPublicKeyHashIn(): any;
            isPublicKeyHashOut(): any;
            isPublicKeyIn(): any;
            isPublicKeyOut(): any;
            isPushOnly(): any;
            isScriptHashIn(): any;
            isScriptHashOut(): any;
            isStandard(): any;
            isWitnessProgram(values: any): any;
            isWitnessPublicKeyHashOut(): any;
            isWitnessScriptHashOut(): any;
            prepend(obj: any): any;
            removeCodeseparators(): any;
            set(obj: any): any;
            toASM(): any;
            toAddress(network: any): any;
            toBuffer(): any;
            toHex(): any;
            toScriptHashOut(): any;
        }
        namespace Script {
            class Interpreter {
                static LOCKTIME_THRESHOLD: number;
                static LOCKTIME_THRESHOLD_BN: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                static MAX_SCRIPT_ELEMENT_SIZE: number;
                static SCRIPT_ENABLE_MONOLITH_OPCODES: number;
                static SCRIPT_ENABLE_REPLAY_PROTECTION: number;
                static SCRIPT_ENABLE_SIGHASH_FORKID: number;
                static SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY: number;
                static SCRIPT_VERIFY_CHECKSEQUENCEVERIFY: number;
                static SCRIPT_VERIFY_CLEANSTACK: number;
                static SCRIPT_VERIFY_DERSIG: number;
                static SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS: number;
                static SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM: number;
                static SCRIPT_VERIFY_LOW_S: number;
                static SCRIPT_VERIFY_MINIMALDATA: number;
                static SCRIPT_VERIFY_MINIMALIF: number;
                static SCRIPT_VERIFY_NONE: number;
                static SCRIPT_VERIFY_NULLDUMMY: number;
                static SCRIPT_VERIFY_NULLFAIL: number;
                static SCRIPT_VERIFY_P2SH: number;
                static SCRIPT_VERIFY_SIGPUSHONLY: number;
                static SCRIPT_VERIFY_STRICTENC: number;
                static SCRIPT_VERIFY_WITNESS: number;
                static SCRIPT_VERIFY_WITNESS_PUBKEYTYPE: number;
                static SEQUENCE_LOCKTIME_DISABLE_FLAG: number;
                static SEQUENCE_LOCKTIME_MASK: number;
                static SEQUENCE_LOCKTIME_TYPE_FLAG: number;
                static castToBool(buf: any): any;
                constructor(obj: any);
                checkLockTime(nLockTime: any): any;
                checkPubkeyEncoding(buf: any): any;
                checkSequence(nSequence: any): any;
                checkSignatureEncoding(buf: any): any;
                evaluate(): any;
                initialize(obj: any): void;
                set(obj: any): void;
                step(): any;
                verify(scriptSig: any, scriptPubkey: any, tx: any, nin: any, flags: any, witness: any, satoshis: any): any;
                verifyWitnessProgram(version: any, program: any, witness: any, satoshis: any, flags: any): any;
            }
            namespace inputIdentifiers {
                function MULTISIG_IN(): any;
                function PUBKEYHASH_IN(): any;
                function PUBKEY_IN(): any;
                function SCRIPTHASH_IN(): any;
            }
            namespace outputIdentifiers {
                function DATA_OUT(): any;
                function MULTISIG_OUT(): any;
                function PUBKEYHASH_OUT(): any;
                function PUBKEY_OUT(): any;
                function SCRIPTHASH_OUT(): any;
            }
        }
        class Transaction {
            static CHANGE_OUTPUT_MAX_SIZE: number;
            static DUST_AMOUNT: number;
            static FEE_PER_KB: number;
            static FEE_SECURITY_MARGIN: number;
            static MAXIMUM_EXTRA_SIZE: number;
            static MAX_MONEY: number;
            static NLOCKTIME_BLOCKHEIGHT_LIMIT: number;
            static NLOCKTIME_MAX_VALUE: number;
            static shallowCopy(transaction: any): any;
            constructor(serialized: any);
            inputs: any;
            outputs: any;
            addData(value: any): any;
            addInput(input: any, outputScript: any, satoshis: any): any;
            addOutput(output: any): any;
            applySignature(signature: any): any;
            change(address: any): any;
            checkedSerialize(opts: any): any;
            clearOutputs(): any;
            enableRBF(): any;
            fee(amount: any): any;
            feePerByte(amount: any): any;
            feePerKb(amount: any): any;
            from(utxo: any, pubkeys: any, threshold: any, nestedWitness: any, opts: any): any;
            fromBuffer(buffer: any): any;
            fromBufferReader(reader: any): any;
            fromObject(arg: any): any;
            fromString(string: any): void;
            getChangeOutput(): any;
            getFee(): any;
            getLockTime(): any;
            getSerializationError(opts: any): any;
            getSignatures(privKey: any, sigtype: any): any;
            hasAllUtxoInfo(): any;
            hasWitnesses(): any;
            inspect(): any;
            invalidSatoshis(): any;
            isCoinbase(): any;
            isFullySigned(): any;
            isRBF(): any;
            isValidSignature(signature: any): any;
            lockUntilBlockHeight(height: any): any;
            lockUntilDate(time: any): any;
            removeInput(txId: any, outputIndex: any): void;
            removeOutput(index: any): void;
            serialize(unsafe: any): any;
            shuffleOutputs(): any;
            sign(privateKey: any, sigtype: any): any;
            sort(): any;
            sortInputs(sortingFunction: any): any;
            sortOutputs(sortingFunction: any): any;
            to(address: any, amount: any): any;
            toBuffer(noWitness: any): any;
            toBufferWriter(writer: any, noWitness: any): any;
            toJSON(): any;
            toObject(): any;
            uncheckedAddInput(input: any): any;
            uncheckedSerialize(): any;
            verify(): any;
            verifySignature(sig: any, pubkey: any, nin: any, subscript: any, sigversion: any, satoshis: any): any;
        }
        namespace Transaction {
            class Input {
                static DEFAULT_LOCKTIME_SEQNUMBER: number;
                static DEFAULT_RBF_SEQNUMBER: number;
                static DEFAULT_SEQNUMBER: number;
                static MAXINT: number;
                static fromBufferReader(br: any): any;
                static fromObject(obj: any): any;
                constructor(params: any);
                addSignature(): void;
                clearSignatures(): void;
                getSatoshisBuffer(): any;
                getSignatures(): void;
                getWitnesses(): any;
                hasWitnesses(): any;
                isFinal(): any;
                isFullySigned(): void;
                isNull(): any;
                isValidSignature(transaction: any, signature: any): any;
                setScript(script: any): any;
                setWitnesses(witnesses: any): void;
                toBufferWriter(writer: any): any;
                toJSON(): any;
                toObject(): any;
            }
            namespace Input {
                class MultiSig {
                    // Too-deep object hierarchy from index.Bitcore.Transaction.Input.MultiSig
                    static OPCODES_SIZE: any;
                    // Too-deep object hierarchy from index.Bitcore.Transaction.Input.MultiSig
                    static SIGNATURE_SIZE: any;
                    // Too-deep object hierarchy from index.Bitcore.Transaction.Input.MultiSig
                    static normalizeSignatures: any;
                    constructor(input: any, pubkeys: any, threshold: any, signatures: any, opts: any, ...args: any[]);
                    publicKeys: any;
                    publicKeyIndex: any;
                    threshold: any;
                    signatures: any;
                }
                class MultiSigScriptHash {
                    // Too-deep object hierarchy from index.Bitcore.Transaction.Input.MultiSigScriptHash
                    static OPCODES_SIZE: any;
                    // Too-deep object hierarchy from index.Bitcore.Transaction.Input.MultiSigScriptHash
                    static PUBKEY_SIZE: any;
                    // Too-deep object hierarchy from index.Bitcore.Transaction.Input.MultiSigScriptHash
                    static SIGNATURE_SIZE: any;
                    constructor(input: any, pubkeys: any, threshold: any, signatures: any, nestedWitness: any, opts: any, ...args: any[]);
                    nestedWitness: any;
                    publicKeys: any;
                    redeemScript: any;
                    publicKeyIndex: any;
                    threshold: any;
                    signatures: any;
                }
                function PublicKey(...args: any[]): void;
                namespace PublicKey {
                    // Too-deep object hierarchy from index.Bitcore.Transaction.Input.PublicKey
                    const SCRIPT_MAX_SIZE: any;
                }
                function PublicKeyHash(...args: any[]): void;
                namespace PublicKeyHash {
                    // Too-deep object hierarchy from index.Bitcore.Transaction.Input.PublicKeyHash
                    const SCRIPT_MAX_SIZE: any;
                }
            }
            class Output {
                static fromBufferReader(br: any): any;
                static fromObject(data: any): any;
                constructor(args: any);
                satoshis: any;
                inspect(): any;
                invalidSatoshis(): any;
                setScript(script: any): any;
                setScriptFromBuffer(buffer: any): void;
                toBufferWriter(writer: any): any;
                toJSON(): any;
                toObject(): any;
            }
            namespace Sighash {
                function sighash(transaction: any, sighashType: any, inputNumber: any, subscript: any): any;
                function sign(transaction: any, privateKey: any, sighashType: any, inputIndex: any, subscript: any): any;
                function verify(transaction: any, signature: any, publicKey: any, inputIndex: any, subscript: any): any;
            }
            namespace SighashWitness {
                function sighash(transaction: any, sighashType: any, inputNumber: any, scriptCode: any, satoshisBuffer: any): any;
                function sign(transaction: any, privateKey: any, sighashType: any, inputIndex: any, scriptCode: any, satoshisBuffer: any): any;
                function verify(transaction: any, signature: any, publicKey: any, inputIndex: any, scriptCode: any, satoshisBuffer: any): any;
            }
            class Signature {
                static fromObject(object: any): any;
                constructor(arg: any);
                hasDefinedHashtype(): any;
                hasLowS(): any;
                set(obj: any): any;
                toBuffer(): any;
                toCompact(i: any, compressed: any): any;
                toDER(): any;
                toJSON(): any;
                toObject(): any;
                toTxFormat(): any;
            }
            class UnspentOutput {
                static fromObject(data: any): any;
                constructor(data: any);
                inspect(): any;
                toJSON(): any;
                toObject(): any;
            }
            namespace sighash {
                function sighash(transaction: any, sighashType: any, inputNumber: any, subscript: any): any;
                function sign(transaction: any, privateKey: any, sighashType: any, inputIndex: any, subscript: any): any;
                function verify(transaction: any, signature: any, publicKey: any, inputIndex: any, subscript: any): any;
            }
        }
        class URI {
            static Members: string[];
            static fromObject(json: any): any;
            static fromString(str: any): any;
            static isValid(arg: any, knownParams: any): any;
            static parse(uri: any): any;
            constructor(data: any, knownParams: any);
            extras: any;
            knownParams: any;
            address: any;
            network: any;
            amount: any;
            message: any;
            inspect(): any;
            toJSON(): any;
            toObject(): any;
        }
        class Unit {
            static BTC: string;
            static bits: string;
            static fromBTC(amount: any): any;
            static fromBits(amount: any): any;
            static fromFiat(amount: any, rate: any): any;
            static fromMicros(amount: any): any;
            static fromMilis(amount: any): any;
            static fromMillis(amount: any): any;
            static fromObject(data: any): any;
            static fromSatoshis(amount: any): any;
            static mBTC: string;
            static satoshis: string;
            static uBTC: string;
            constructor(amount: any, code: any);
            atRate(rate: any): any;
            inspect(): any;
            to(code: any): any;
            toBTC(): any;
            toBits(): any;
            toJSON(): any;
            toMicros(): any;
            toMilis(): any;
            toMillis(): any;
            toObject(): any;
            toSatoshis(): any;
        }
        namespace crypto {
            class BN {
                // Circular reference from index.Bitcore.crypto.BN
                static BN: any;
                static Minus1: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                static One: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                static Zero: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                static fromBuffer(buf: any, opts: any): any;
                static fromNumber(n: any): any;
                static fromSM(buf: any, opts: any): any;
                static fromScriptNumBuffer(buf: any, fRequireMinimal: any, size: any): any;
                static fromString(str: any, base: any): any;
                static isBN(num: any): any;
                static max(left: any, right: any): any;
                static min(left: any, right: any): any;
                static mont(num: any): any;
                static pad(buf: any, natlen: any, size: any): any;
                static red(num: any): any;
                static trim(buf: any, natlen: any): any;
                static wordSize: number;
                constructor(number: any, base: any, endian: any);
                negative: any;
                words: any;
                length: any;
                red: any;
                abs(): any;
                add(num: any): any;
                addn(num: any): any;
                and(num: any): any;
                andln(num: any): any;
                bincn(bit: any): any;
                bitLength(): any;
                byteLength(): any;
                clone(): any;
                cmp(num: any): any;
                cmpn(num: any): any;
                copy(dest: any): void;
                div(num: any): any;
                divRound(num: any): any;
                divmod(num: any, mode: any, positive: any): any;
                divn(num: any): any;
                egcd(p: any): any;
                eq(num: any): any;
                eqn(num: any): any;
                forceRed(ctx: any): any;
                fromRed(): any;
                fromTwos(width: any): any;
                gcd(num: any): any;
                gt(num: any): any;
                gte(num: any): any;
                gten(num: any): any;
                gtn(num: any): any;
                iabs(): any;
                iadd(num: any): any;
                iaddn(num: any): any;
                iand(num: any): any;
                idivn(num: any): any;
                imaskn(bits: any): any;
                imul(num: any): any;
                imuln(num: any): any;
                ineg(): any;
                inotn(width: any): any;
                inspect(): any;
                invm(num: any): any;
                ior(num: any): any;
                isEven(): any;
                isNeg(): any;
                isOdd(): any;
                isZero(): any;
                ishln(bits: any): any;
                ishrn(bits: any, hint: any, extended: any): any;
                isqr(): any;
                isub(num: any): any;
                isubn(num: any): any;
                iuand(num: any): any;
                iuor(num: any): any;
                iushln(bits: any): any;
                iushrn(bits: any, hint: any, extended: any): any;
                iuxor(num: any): any;
                ixor(num: any): any;
                lt(num: any): any;
                lte(num: any): any;
                lten(num: any): any;
                ltn(num: any): any;
                maskn(bits: any): any;
                mod(num: any): any;
                modn(num: any): any;
                mul(num: any): any;
                mulTo(num: any, out: any): any;
                mulf(num: any): any;
                muln(num: any): any;
                neg(): any;
                notn(width: any): any;
                or(num: any): any;
                pow(num: any): any;
                redAdd(num: any): any;
                redIAdd(num: any): any;
                redIMul(num: any): any;
                redISqr(): any;
                redISub(num: any): any;
                redInvm(): any;
                redMul(num: any): any;
                redNeg(): any;
                redPow(num: any): any;
                redShl(num: any): any;
                redSqr(): any;
                redSqrt(): any;
                redSub(num: any): any;
                setn(bit: any, val: any): any;
                shln(bits: any): any;
                shrn(bits: any): any;
                sqr(): any;
                strip(): any;
                sub(num: any): any;
                subn(num: any): any;
                testn(bit: any): any;
                toArray(endian: any, length: any): any;
                toArrayLike(ArrayType: any, endian: any, length: any): any;
                toBuffer(opts: any): any;
                toJSON(): any;
                toNumber(): any;
                toRed(ctx: any): any;
                toSM(opts: any): any;
                toSMBigEndian(): any;
                toScriptNumBuffer(): any;
                toString(base: any, padding: any): any;
                toTwos(width: any): any;
                uand(num: any): any;
                ucmp(num: any): any;
                umod(num: any): any;
                uor(num: any): any;
                ushln(bits: any): any;
                ushrn(bits: any): any;
                uxor(num: any): any;
                xor(num: any): any;
                zeroBits(): any;
            }
            class ECDSA {
                static fromString(str: any): any;
                static sign(hashbuf: any, privkey: any, endian: any): any;
                static toLowS(s: any): any;
                static verify(hashbuf: any, sig: any, pubkey: any, endian: any): any;
                constructor(obj: any);
                calci(): any;
                deterministicK(badrs: any): any;
                privkey2pubkey(): void;
                randomK(): any;
                set(obj: any): any;
                sigError(): any;
                sign(): any;
                signRandomK(): any;
                toPublicKey(): any;
                verify(): any;
            }
            namespace Hash {
                function hmac(hashf: any, data: any, key: any): any;
                function ripemd160(buf: any): any;
                function sha1(buf: any): any;
                namespace sha1 {
                    // Too-deep object hierarchy from index.Bitcore.crypto.Hash.sha1
                    const blocksize: any;
                }
                function sha256(buf: any): any;
                namespace sha256 {
                    // Too-deep object hierarchy from index.Bitcore.crypto.Hash.sha256
                    const blocksize: any;
                }
                function sha256hmac(data: any, key: any): any;
                function sha256ripemd160(buf: any): any;
                function sha256sha256(buf: any): any;
                function sha512(buf: any): any;
                namespace sha512 {
                    // Too-deep object hierarchy from index.Bitcore.crypto.Hash.sha512
                    const blocksize: any;
                }
                function sha512hmac(data: any, key: any): any;
            }
            class Point {
                static fromX(odd: any, x: any): any;
                static getG(): any;
                static getN(): any;
                static pointToCompressed(point: any): any;
                constructor(x: any, y: any, isRed: any);
                add(p: any): any;
                dbl(): any;
                dblp(k: any): any;
                encode(enc: any, compact: any): any;
                encodeCompressed(enc: any): any;
                eq(p: any): any;
                getX(): any;
                getY(): any;
                inspect(): any;
                isInfinity(): any;
                jmulAdd(k1: any, p2: any, k2: any): any;
                mul(k: any): any;
                mulAdd(k1: any, p2: any, k2: any): any;
                neg(_precompute: any): any;
                precompute(power: any): any;
                toJ(): any;
                toJSON(): any;
                validate(): any;
            }
            function Random(): void;
            namespace Random {
                function getPseudoRandomBuffer(size: any): any;
                function getRandomBuffer(size: any): any;
                function getRandomBufferBrowser(size: any): any;
                function getRandomBufferNode(size: any): any;
            }
            class Signature {
                static SIGHASH_ALL: number;
                static SIGHASH_ANYONECANPAY: number;
                static SIGHASH_NONE: number;
                static SIGHASH_SINGLE: number;
                static fromBuffer(buf: any, strict: any): any;
                static fromCompact(buf: any): any;
                static fromDER(buf: any, strict: any): any;
                static fromString(str: any): any;
                static fromTxFormat(buf: any): any;
                static isTxDER(buf: any): any;
                static parseDER(buf: any, strict: any): any;
                constructor(r: any, s: any);
                hasDefinedHashtype(): any;
                hasLowS(): any;
                set(obj: any): any;
                toBuffer(): any;
                toCompact(i: any, compressed: any): any;
                toDER(): any;
                toTxFormat(): any;
            }
        }
        namespace deps {
            class Buffer {
                static BYTES_PER_ELEMENT: number;
                static alloc(size: any, fill: any, encoding: any): any;
                static allocUnsafe(size: any): any;
                static allocUnsafeSlow(size: any): any;
                static byteLength(string: any, encoding: any, ...args: any[]): any;
                static compare(buf1: any, buf2: any): any;
                static concat(list: any, length: any): any;
                static from(value: any, encodingOrOffset: any, length: any): any;
                static isBuffer(b: any): any;
                static isEncoding(encoding: any): any;
                static of(items: any): any;
                static poolSize: number;
                constructor(arg: any, encodingOrOffset: any, length: any);
                asciiSlice(): any;
                asciiWrite(): any;
                base64Slice(): any;
                base64Write(): any;
                compare(target: any, start: any, end: any, thisStart: any, thisEnd: any, ...args: any[]): any;
                copy(target: any, targetStart: any, sourceStart: any, sourceEnd: any): any;
                copyWithin(p0: any, p1: any): any;
                entries(): any;
                equals(otherBuffer: any): any;
                every(p0: any): any;
                fill(val: any, start: any, end: any, encoding: any): any;
                filter(p0: any): any;
                find(p0: any): any;
                findIndex(p0: any): any;
                forEach(p0: any): any;
                hexSlice(): any;
                hexWrite(): any;
                includes(val: any, byteOffset: any, encoding: any): any;
                indexOf(val: any, byteOffset: any, encoding: any): any;
                inspect(): any;
                join(p0: any): any;
                keys(): any;
                lastIndexOf(val: any, byteOffset: any, encoding: any): any;
                latin1Slice(): any;
                latin1Write(): any;
                map(p0: any): any;
                readDoubleBE(offset: any): any;
                readDoubleLE(offset: any): any;
                readFloatBE(offset: any): any;
                readFloatLE(offset: any): any;
                readInt16BE(offset: any): any;
                readInt16LE(offset: any): any;
                readInt32BE(offset: any): any;
                readInt32LE(offset: any): any;
                readInt8(offset: any): any;
                readIntBE(offset: any, byteLength: any): any;
                readIntLE(offset: any, byteLength: any): any;
                readUInt16BE(offset: any): any;
                readUInt16LE(offset: any): any;
                readUInt32BE(offset: any): any;
                readUInt32LE(offset: any): any;
                readUInt8(offset: any): any;
                readUIntBE(offset: any, byteLength: any): any;
                readUIntLE(offset: any, byteLength: any): any;
                reduce(p0: any): any;
                reduceRight(p0: any): any;
                reverse(): any;
                set(p0: any): any;
                slice(start: any, end: any): any;
                some(p0: any): any;
                sort(p0: any): any;
                subarray(p0: any, p1: any): any;
                swap16(): any;
                swap32(): any;
                swap64(): any;
                toJSON(): any;
                toLocaleString(encoding: any, start: any, end: any, ...args: any[]): any;
                toString(encoding: any, start: any, end: any, ...args: any[]): any;
                ucs2Slice(): any;
                ucs2Write(): any;
                utf8Slice(): any;
                utf8Write(): any;
                values(): any;
                write(string: any, offset: any, length: any, encoding: any): any;
                writeDoubleBE(val: any, offset: any): any;
                writeDoubleLE(val: any, offset: any): any;
                writeFloatBE(val: any, offset: any): any;
                writeFloatLE(val: any, offset: any): any;
                writeInt16BE(value: any, offset: any): any;
                writeInt16LE(value: any, offset: any): any;
                writeInt32BE(value: any, offset: any): any;
                writeInt32LE(value: any, offset: any): any;
                writeInt8(value: any, offset: any): any;
                writeIntBE(value: any, offset: any, byteLength: any): any;
                writeIntLE(value: any, offset: any, byteLength: any): any;
                writeUInt16BE(value: any, offset: any): any;
                writeUInt16LE(value: any, offset: any): any;
                writeUInt32BE(value: any, offset: any): any;
                writeUInt32LE(value: any, offset: any): any;
                writeUInt8(value: any, offset: any): any;
                writeUIntBE(value: any, offset: any, byteLength: any): any;
                writeUIntLE(value: any, offset: any, byteLength: any): any;
            }
            class bnjs {
                // Circular reference from index.Bitcore.deps.bnjs
                static BN: any;
                static Minus1: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                static One: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                static Zero: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                static fromBuffer(buf: any, opts: any): any;
                static fromNumber(n: any): any;
                static fromSM(buf: any, opts: any): any;
                static fromScriptNumBuffer(buf: any, fRequireMinimal: any, size: any): any;
                static fromString(str: any, base: any): any;
                static isBN(num: any): any;
                static max(left: any, right: any): any;
                static min(left: any, right: any): any;
                static mont(num: any): any;
                static pad(buf: any, natlen: any, size: any): any;
                static red(num: any): any;
                static trim(buf: any, natlen: any): any;
                static wordSize: number;
                constructor(number: any, base: any, endian: any);
                negative: any;
                words: any;
                length: any;
                red: any;
                abs(): any;
                add(num: any): any;
                addn(num: any): any;
                and(num: any): any;
                andln(num: any): any;
                bincn(bit: any): any;
                bitLength(): any;
                byteLength(): any;
                clone(): any;
                cmp(num: any): any;
                cmpn(num: any): any;
                copy(dest: any): void;
                div(num: any): any;
                divRound(num: any): any;
                divmod(num: any, mode: any, positive: any): any;
                divn(num: any): any;
                egcd(p: any): any;
                eq(num: any): any;
                eqn(num: any): any;
                forceRed(ctx: any): any;
                fromRed(): any;
                fromTwos(width: any): any;
                gcd(num: any): any;
                gt(num: any): any;
                gte(num: any): any;
                gten(num: any): any;
                gtn(num: any): any;
                iabs(): any;
                iadd(num: any): any;
                iaddn(num: any): any;
                iand(num: any): any;
                idivn(num: any): any;
                imaskn(bits: any): any;
                imul(num: any): any;
                imuln(num: any): any;
                ineg(): any;
                inotn(width: any): any;
                inspect(): any;
                invm(num: any): any;
                ior(num: any): any;
                isEven(): any;
                isNeg(): any;
                isOdd(): any;
                isZero(): any;
                ishln(bits: any): any;
                ishrn(bits: any, hint: any, extended: any): any;
                isqr(): any;
                isub(num: any): any;
                isubn(num: any): any;
                iuand(num: any): any;
                iuor(num: any): any;
                iushln(bits: any): any;
                iushrn(bits: any, hint: any, extended: any): any;
                iuxor(num: any): any;
                ixor(num: any): any;
                lt(num: any): any;
                lte(num: any): any;
                lten(num: any): any;
                ltn(num: any): any;
                maskn(bits: any): any;
                mod(num: any): any;
                modn(num: any): any;
                mul(num: any): any;
                mulTo(num: any, out: any): any;
                mulf(num: any): any;
                muln(num: any): any;
                neg(): any;
                notn(width: any): any;
                or(num: any): any;
                pow(num: any): any;
                redAdd(num: any): any;
                redIAdd(num: any): any;
                redIMul(num: any): any;
                redISqr(): any;
                redISub(num: any): any;
                redInvm(): any;
                redMul(num: any): any;
                redNeg(): any;
                redPow(num: any): any;
                redShl(num: any): any;
                redSqr(): any;
                redSqrt(): any;
                redSub(num: any): any;
                setn(bit: any, val: any): any;
                shln(bits: any): any;
                shrn(bits: any): any;
                sqr(): any;
                strip(): any;
                sub(num: any): any;
                subn(num: any): any;
                testn(bit: any): any;
                toArray(endian: any, length: any): any;
                toArrayLike(ArrayType: any, endian: any, length: any): any;
                toBuffer(opts: any): any;
                toJSON(): any;
                toNumber(): any;
                toRed(ctx: any): any;
                toSM(opts: any): any;
                toSMBigEndian(): any;
                toScriptNumBuffer(): any;
                toString(base: any, padding: any): any;
                toTwos(width: any): any;
                uand(num: any): any;
                ucmp(num: any): any;
                umod(num: any): any;
                uor(num: any): any;
                ushln(bits: any): any;
                ushrn(bits: any): any;
                uxor(num: any): any;
                xor(num: any): any;
                zeroBits(): any;
            }
            namespace bs58 {
                function decode(string: any): any;
                function decodeUnsafe(source: any): any;
                function encode(source: any): any;
            }
            namespace elliptic {
                const curve: {
                    base: any;
                    edwards: any;
                    mont: any;
                    short: any;
                };
                const curves: {
                    PresetCurve: any;
                    curve25519: any;
                    ed25519: any;
                    p192: any;
                    p224: any;
                    p256: any;
                    p384: any;
                    p521: any;
                    secp256k1: any;
                };
                class ec {
                    constructor(options: any);
                    curve: any;
                    n: any;
                    nh: any;
                    g: any;
                    hash: any;
                }
                class eddsa {
                    constructor(curve: any);
                    curve: any;
                    g: any;
                    pointClass: any;
                    encodingLength: any;
                    hash: any;
                }
                function rand(len: any): any;
                namespace rand {
                    // Too-deep object hierarchy from index.Bitcore.deps.elliptic.rand
                    const Rand: any;
                }
                const utils: {
                    assert: any;
                    cachedProperty: any;
                    encode: any;
                    getJSF: any;
                    getNAF: any;
                    intFromLE: any;
                    parseBytes: any;
                    toArray: any;
                    toHex: any;
                    zero2: any;
                };
                const version: string;
            }
        }
        namespace encoding {
            class Base58 {
                static decode(str: any): any;
                static encode(buf: any): any;
                static validCharacters(chars: any): any;
                constructor(obj: any);
                fromBuffer(buf: any): any;
                fromString(str: any): any;
                set(obj: any): any;
                toBuffer(): any;
            }
            class Base58Check {
                static checksum(buffer: any): any;
                static decode(s: any): any;
                static encode(buf: any): any;
                static validChecksum(data: any, checksum: any): any;
                constructor(obj: any);
                fromBuffer(buf: any): any;
                fromString(str: any): any;
                set(obj: any): any;
                toBuffer(): any;
            }
            class BufferReader {
                constructor(buf: any);
                eof(): any;
                finished(): any;
                read(len: any): any;
                readAll(): any;
                readInt32LE(): any;
                readReverse(len: any): any;
                readUInt16BE(): any;
                readUInt16LE(): any;
                readUInt32BE(): any;
                readUInt32LE(): any;
                readUInt64BEBN(): any;
                readUInt64LEBN(): any;
                readUInt8(): any;
                readVarLengthBuffer(): any;
                readVarintBN(): any;
                readVarintBuf(): any;
                readVarintNum(): any;
                reverse(): any;
                set(obj: any): any;
            }
            class BufferWriter {
                static varintBufBN(bn: any): any;
                static varintBufNum(n: any): any;
                constructor(obj: any);
                bufLen: any;
                bufs: any;
                concat(): any;
                set(obj: any): any;
                toBuffer(): any;
                write(buf: any): any;
                writeInt32LE(n: any): any;
                writeReverse(buf: any): any;
                writeUInt16BE(n: any): any;
                writeUInt16LE(n: any): any;
                writeUInt32BE(n: any): any;
                writeUInt32LE(n: any): any;
                writeUInt64BEBN(bn: any): any;
                writeUInt64LEBN(bn: any): any;
                writeUInt8(n: any): any;
                writeVarintBN(bn: any): any;
                writeVarintNum(n: any): any;
            }
            class Varint {
                constructor(buf: any);
                buf: any;
                fromBN(bn: any): any;
                fromBuffer(buf: any): any;
                fromBufferReader(br: any): any;
                fromNumber(num: any): any;
                fromString(str: any): any;
                set(obj: any): any;
                toBN(): any;
                toBuffer(): any;
                toNumber(): any;
            }
        }
        class errors {
            static AbstractMethodInvoked(...args: any[]): void;
            static InvalidArgument(...args: any[]): void;
            static InvalidArgumentType(...args: any[]): void;
            static InvalidB58Char(...args: any[]): void;
            static InvalidB58Checksum(...args: any[]): void;
            static InvalidNetwork(...args: any[]): void;
            static InvalidNetworkArgument(...args: any[]): void;
            static InvalidState(...args: any[]): void;
            static NotImplemented(...args: any[]): void;
            static extend(spec: any): any;
            message: any;
            stack: any;
        }
        namespace errors {
            class HDPrivateKey {
                static InvalidDerivationArgument(...args: any[]): void;
                static InvalidLength(...args: any[]): void;
                static InvalidPath(...args: any[]): void;
                static UnrecognizedArgument(...args: any[]): void;
                constructor(...args: any[]);
                message: any;
                stack: any;
            }
            namespace HDPrivateKey {
                class InvalidEntropyArgument {
                    // Too-deep object hierarchy from index.Bitcore.errors.HDPrivateKey.InvalidEntropyArgument
                    static NotEnoughEntropy: any;
                    // Too-deep object hierarchy from index.Bitcore.errors.HDPrivateKey.InvalidEntropyArgument
                    static TooMuchEntropy: any;
                    constructor(...args: any[]);
                    message: any;
                    stack: any;
                }
            }
            class HDPublicKey {
                static ArgumentIsPrivateExtended(...args: any[]): void;
                static InvalidDerivationArgument(...args: any[]): void;
                static InvalidIndexCantDeriveHardened(...args: any[]): void;
                static InvalidLength(...args: any[]): void;
                static InvalidPath(...args: any[]): void;
                static MustSupplyArgument(...args: any[]): void;
                static UnrecognizedArgument(...args: any[]): void;
                constructor(...args: any[]);
                message: any;
                stack: any;
            }
            class MerkleBlock {
                static InvalidMerkleTree(...args: any[]): void;
                constructor(...args: any[]);
                message: any;
                stack: any;
            }
            class Mnemonic {
                static InvalidEntropy(...args: any[]): void;
                static InvalidMnemonic(...args: any[]): void;
                static UnknownWordlist(...args: any[]): void;
                constructor(...args: any[]);
                message: any;
                stack: any;
            }
            class Script {
                static CantDeriveAddress(...args: any[]): void;
                static InvalidBuffer(...args: any[]): void;
                static UnrecognizedAddress(...args: any[]): void;
                constructor(...args: any[]);
                message: any;
                stack: any;
            }
            class Transaction {
                static BlockHeightTooHigh(...args: any[]): void;
                static ChangeAddressMissing(...args: any[]): void;
                static DustOutputs(...args: any[]): void;
                static InvalidIndex(...args: any[]): void;
                static InvalidOutputAmountSum(...args: any[]): void;
                static InvalidSatoshis(...args: any[]): void;
                static InvalidSorting(...args: any[]): void;
                static LockTimeTooEarly(...args: any[]): void;
                static MissingSignatures(...args: any[]): void;
                static NLockTimeOutOfRange(...args: any[]): void;
                static NeedMoreInfo(...args: any[]): void;
                static UnableToVerifySignature(...args: any[]): void;
                constructor(...args: any[]);
                message: any;
                stack: any;
            }
            namespace Transaction {
                class FeeError {
                    // Too-deep object hierarchy from index.Bitcore.errors.Transaction.FeeError
                    static Different: any;
                    // Too-deep object hierarchy from index.Bitcore.errors.Transaction.FeeError
                    static TooLarge: any;
                    // Too-deep object hierarchy from index.Bitcore.errors.Transaction.FeeError
                    static TooSmall: any;
                    constructor(...args: any[]);
                    message: any;
                    stack: any;
                }
                class Input {
                    // Too-deep object hierarchy from index.Bitcore.errors.Transaction.Input
                    static MissingPreviousOutput: any;
                    // Too-deep object hierarchy from index.Bitcore.errors.Transaction.Input
                    static MissingScript: any;
                    // Too-deep object hierarchy from index.Bitcore.errors.Transaction.Input
                    static UnsupportedScript: any;
                    constructor(...args: any[]);
                    message: any;
                    stack: any;
                }
            }
            class Unit {
                static InvalidRate(...args: any[]): void;
                static UnknownCode(...args: any[]): void;
                constructor(...args: any[]);
                message: any;
                stack: any;
            }
        }
        const util: {
            buffer: {
                EMPTY_BUFFER: Buffer;
                NULL_HASH: Buffer;
                bufferToHex: Function;
                concat: Function;
                copy: Function;
                emptyBuffer: Function;
                equal: Function;
                equals: Function;
                fill: Function;
                hexToBuffer: Function;
                integerAsBuffer: Function;
                integerAsSingleByteBuffer: Function;
                integerFromBuffer: Function;
                integerFromSingleByteBuffer: Function;
                isBuffer: Function;
                reverse: Function;
            };
            js: {
                cloneArray: Function;
                defineImmutable: Function;
                isHexa: Function;
                isHexaString: Function;
                isNaturalNumber: Function;
                isValidJSON: Function;
            };
            preconditions: {
                checkArgument: Function;
                checkArgumentType: Function;
                checkState: Function;
            };
        };
        const version: string;
        function versionGuard(version: any): void;
    }
    namespace BitcoreCash {
        class Address {
            static PayToPublicKeyHash: string;
            static PayToScriptHash: string;
            static createMultisig(publicKeys: any, threshold: any, network: any): any;
            static fromBuffer(buffer: any, network: any, type: any): any;
            static fromObject(obj: any): any;
            static fromPublicKey(data: any, network: any): any;
            static fromPublicKeyHash(hash: any, network: any): any;
            static fromScript(script: any, network: any): any;
            static fromScriptHash(hash: any, network: any): any;
            static fromString(str: any, network: any, type: any): any;
            static getValidationError(data: any, network: any, type: any): any;
            static isValid(data: any, network: any, type: any): any;
            static payingTo(script: any, network: any): any;
            constructor(data: any, network: any, type: any);
            inspect(): any;
            isPayToPublicKeyHash(): any;
            isPayToScriptHash(): any;
            toBuffer(): any;
            toCashAddress(stripPrefix: any): any;
            toCashBuffer(): any;
            toJSON(): any;
            toLegacyAddress(): any;
            toObject(): any;
            toString(stripPrefix: any): any;
        }
        class Block {
            static MAX_BLOCK_SIZE: number;
            static Values: {
                NULL_HASH: Buffer;
                START_OF_BLOCK: number;
            };
            static fromBuffer(buf: any): any;
            static fromBufferReader(br: any): any;
            static fromObject(obj: any): any;
            static fromRawBlock(data: any): any;
            static fromString(str: any): any;
            constructor(arg: any);
            getMerkleRoot(): any;
            getMerkleTree(): any;
            getTransactionHashes(): any;
            inspect(): any;
            toBuffer(): any;
            toBufferWriter(bw: any): any;
            toJSON(): any;
            toObject(): any;
            validMerkleRoot(): any;
        }
        namespace Block {
            class BlockHeader {
                static Constants: {
                    LARGEST_HASH: any;
                    MAX_TIME_OFFSET: any;
                    START_OF_HEADER: any;
                };
                static fromBuffer(buf: any): any;
                static fromBufferReader(br: any): any;
                static fromObject(obj: any): any;
                static fromRawBlock(data: any): any;
                static fromString(str: any): any;
                constructor(arg: any);
                version: any;
                prevHash: any;
                merkleRoot: any;
                time: any;
                timestamp: any;
                bits: any;
                nonce: any;
                getDifficulty(): any;
                getTargetDifficulty(bits: any): any;
                inspect(): any;
                toBuffer(): any;
                toBufferWriter(bw: any): any;
                toJSON(): any;
                toObject(): any;
                validProofOfWork(): any;
                validTimestamp(): any;
            }
            class MerkleBlock {
                static fromBuffer(buf: any): any;
                static fromBufferReader(br: any): any;
                static fromObject(obj: any): any;
                constructor(arg: any);
                filterdTxsHash(): any;
                hasTransaction(tx: any): any;
                toBuffer(): any;
                toBufferWriter(bw: any): any;
                toJSON(): any;
                toObject(): any;
                validMerkleTree(): any;
            }
        }
        class BlockHeader {
            static Constants: {
                LARGEST_HASH: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                MAX_TIME_OFFSET: number;
                START_OF_HEADER: number;
            };
            static fromBuffer(buf: any): any;
            static fromBufferReader(br: any): any;
            static fromObject(obj: any): any;
            static fromRawBlock(data: any): any;
            static fromString(str: any): any;
            constructor(arg: any);
            version: any;
            prevHash: any;
            merkleRoot: any;
            time: any;
            timestamp: any;
            bits: any;
            nonce: any;
            getDifficulty(): any;
            getTargetDifficulty(bits: any): any;
            inspect(): any;
            toBuffer(): any;
            toBufferWriter(bw: any): any;
            toJSON(): any;
            toObject(): any;
            validProofOfWork(): any;
            validTimestamp(): any;
        }
        class HDPrivateKey {
            static ChainCodeEnd: number;
            static ChainCodeSize: number;
            static ChainCodeStart: number;
            static CheckSumSize: number;
            static ChecksumEnd: number;
            static ChecksumStart: number;
            static ChildIndexEnd: number;
            static ChildIndexSize: number;
            static ChildIndexStart: number;
            static DataLength: number;
            static DefaultChildIndex: number;
            static DefaultDepth: number;
            static DefaultFingerprint: number;
            static DepthEnd: number;
            static DepthSize: number;
            static DepthStart: number;
            static Hardened: number;
            static MaxIndex: number;
            static ParentFingerPrintEnd: number;
            static ParentFingerPrintSize: number;
            static ParentFingerPrintStart: number;
            static PrivateKeyEnd: number;
            static PrivateKeySize: number;
            static PrivateKeyStart: number;
            static RootElementAlias: string[];
            static SerializedByteSize: number;
            static VersionEnd: number;
            static VersionSize: number;
            static VersionStart: number;
            static fromBuffer(arg: any): any;
            static fromObject(arg: any): any;
            static fromSeed(hexa: any, network: any): any;
            static fromString(arg: any): any;
            static getSerializedError(data: any, network: any): any;
            static isValidPath(arg: any, hardened: any): any;
            static isValidSerialized(data: any, network: any): any;
            constructor(arg: any);
            derive(arg: any, hardened: any): any;
            deriveChild(arg: any, hardened: any): any;
            deriveNonCompliantChild(arg: any, hardened: any): any;
            inspect(): any;
            toBuffer(): any;
            toJSON(): any;
            toObject(): any;
        }
        class HDPublicKey {
            static ChainCodeEnd: number;
            static ChainCodeSize: number;
            static ChainCodeStart: number;
            static CheckSumSize: number;
            static ChecksumEnd: number;
            static ChecksumStart: number;
            static ChildIndexEnd: number;
            static ChildIndexSize: number;
            static ChildIndexStart: number;
            static DataSize: number;
            static DepthEnd: number;
            static DepthSize: number;
            static DepthStart: number;
            static Hardened: number;
            static ParentFingerPrintEnd: number;
            static ParentFingerPrintSize: number;
            static ParentFingerPrintStart: number;
            static PublicKeyEnd: number;
            static PublicKeySize: number;
            static PublicKeyStart: number;
            static RootElementAlias: string[];
            static SerializedByteSize: number;
            static VersionEnd: number;
            static VersionSize: number;
            static VersionStart: number;
            static fromBuffer(arg: any): any;
            static fromObject(arg: any): any;
            static fromString(arg: any): any;
            static getSerializedError(data: any, network: any): any;
            static isValidPath(arg: any): any;
            static isValidSerialized(data: any, network: any): any;
            constructor(arg: any);
            derive(arg: any, hardened: any): any;
            deriveChild(arg: any, hardened: any): any;
            inspect(): any;
            toBuffer(): any;
            toJSON(): any;
            toObject(): any;
        }
        class MerkleBlock {
            static fromBuffer(buf: any): any;
            static fromBufferReader(br: any): any;
            static fromObject(obj: any): any;
            constructor(arg: any);
            filterdTxsHash(): any;
            hasTransaction(tx: any): any;
            toBuffer(): any;
            toBufferWriter(bw: any): any;
            toJSON(): any;
            toObject(): any;
            validMerkleTree(): any;
        }
        namespace Networks {
            function add(data: any): any;
            const defaultNetwork: {
                alias: string;
                dnsSeeds: any[];
                name: string;
                networkMagic: Buffer;
                port: number;
                prefix: string;
                prefixArray: any[];
                privatekey: number;
                pubkeyhash: number;
                scripthash: number;
                xprivkey: number;
                xpubkey: number;
            };
            function disableRegtest(): void;
            function enableRegtest(): void;
            function get(arg: any, keys: any): any;
            const livenet: {
                alias: string;
                dnsSeeds: any[];
                name: string;
                networkMagic: Buffer;
                port: number;
                prefix: string;
                prefixArray: any[];
                privatekey: number;
                pubkeyhash: number;
                scripthash: number;
                xprivkey: number;
                xpubkey: number;
            };
            const mainnet: {
                alias: string;
                dnsSeeds: any[];
                name: string;
                networkMagic: Buffer;
                port: number;
                prefix: string;
                prefixArray: any[];
                privatekey: number;
                pubkeyhash: number;
                scripthash: number;
                xprivkey: number;
                xpubkey: number;
            };
            const regtest: {
                alias: any;
                dnsSeeds: any[];
                name: string;
                networkMagic: Buffer;
                port: number;
                prefix: string;
                prefixArray: any[];
                privatekey: number;
                pubkeyhash: number;
                scripthash: number;
                xprivkey: number;
                xpubkey: number;
            };
            function remove(network: any): void;
            const testnet: {
                alias: any;
                dnsSeeds: any[];
                name: string;
                networkMagic: Buffer;
                port: number;
                prefix: string;
                prefixArray: any[];
                privatekey: number;
                pubkeyhash: number;
                scripthash: number;
                xprivkey: number;
                xpubkey: number;
            };
        }
        class Opcode {
            static OP_0: number;
            static OP_0NOTEQUAL: number;
            static OP_1: number;
            static OP_10: number;
            static OP_11: number;
            static OP_12: number;
            static OP_13: number;
            static OP_14: number;
            static OP_15: number;
            static OP_16: number;
            static OP_1ADD: number;
            static OP_1NEGATE: number;
            static OP_1SUB: number;
            static OP_2: number;
            static OP_2DIV: number;
            static OP_2DROP: number;
            static OP_2DUP: number;
            static OP_2MUL: number;
            static OP_2OVER: number;
            static OP_2ROT: number;
            static OP_2SWAP: number;
            static OP_3: number;
            static OP_3DUP: number;
            static OP_4: number;
            static OP_5: number;
            static OP_6: number;
            static OP_7: number;
            static OP_8: number;
            static OP_9: number;
            static OP_ABS: number;
            static OP_ADD: number;
            static OP_AND: number;
            static OP_BIN2NUM: number;
            static OP_BOOLAND: number;
            static OP_BOOLOR: number;
            static OP_CAT: number;
            static OP_CHECKDATASIG: number;
            static OP_CHECKDATASIGVERIFY: number;
            static OP_CHECKLOCKTIMEVERIFY: number;
            static OP_CHECKMULTISIG: number;
            static OP_CHECKMULTISIGVERIFY: number;
            static OP_CHECKSEQUENCEVERIFY: number;
            static OP_CHECKSIG: number;
            static OP_CHECKSIGVERIFY: number;
            static OP_CODESEPARATOR: number;
            static OP_DEPTH: number;
            static OP_DIV: number;
            static OP_DROP: number;
            static OP_DUP: number;
            static OP_ELSE: number;
            static OP_ENDIF: number;
            static OP_EQUAL: number;
            static OP_EQUALVERIFY: number;
            static OP_FALSE: number;
            static OP_FROMALTSTACK: number;
            static OP_GREATERTHAN: number;
            static OP_GREATERTHANOREQUAL: number;
            static OP_HASH160: number;
            static OP_HASH256: number;
            static OP_IF: number;
            static OP_IFDUP: number;
            static OP_INVALIDOPCODE: number;
            static OP_INVERT: number;
            static OP_LESSTHAN: number;
            static OP_LESSTHANOREQUAL: number;
            static OP_LSHIFT: number;
            static OP_MAX: number;
            static OP_MIN: number;
            static OP_MOD: number;
            static OP_MUL: number;
            static OP_NEGATE: number;
            static OP_NIP: number;
            static OP_NOP: number;
            static OP_NOP1: number;
            static OP_NOP10: number;
            static OP_NOP2: number;
            static OP_NOP3: number;
            static OP_NOP4: number;
            static OP_NOP5: number;
            static OP_NOP6: number;
            static OP_NOP7: number;
            static OP_NOP8: number;
            static OP_NOP9: number;
            static OP_NOT: number;
            static OP_NOTIF: number;
            static OP_NUM2BIN: number;
            static OP_NUMEQUAL: number;
            static OP_NUMEQUALVERIFY: number;
            static OP_NUMNOTEQUAL: number;
            static OP_OR: number;
            static OP_OVER: number;
            static OP_PICK: number;
            static OP_PREFIX_BEGIN: number;
            static OP_PREFIX_END: number;
            static OP_PUBKEY: number;
            static OP_PUBKEYHASH: number;
            static OP_PUBKEYS: number;
            static OP_PUSHDATA1: number;
            static OP_PUSHDATA2: number;
            static OP_PUSHDATA4: number;
            static OP_RESERVED: number;
            static OP_RESERVED1: number;
            static OP_RESERVED2: number;
            static OP_RETURN: number;
            static OP_RIPEMD160: number;
            static OP_ROLL: number;
            static OP_ROT: number;
            static OP_RSHIFT: number;
            static OP_SHA1: number;
            static OP_SHA256: number;
            static OP_SIZE: number;
            static OP_SMALLINTEGER: number;
            static OP_SPLIT: number;
            static OP_SUB: number;
            static OP_SWAP: number;
            static OP_TOALTSTACK: number;
            static OP_TRUE: number;
            static OP_TUCK: number;
            static OP_VER: number;
            static OP_VERIF: number;
            static OP_VERIFY: number;
            static OP_VERNOTIF: number;
            static OP_WITHIN: number;
            static OP_XOR: number;
            static fromBuffer(buf: any): any;
            static fromNumber(num: any): any;
            static fromString(str: any): any;
            static isSmallIntOp(opcode: any): any;
            static map: {
                OP_0: number;
                OP_0NOTEQUAL: number;
                OP_1: number;
                OP_10: number;
                OP_11: number;
                OP_12: number;
                OP_13: number;
                OP_14: number;
                OP_15: number;
                OP_16: number;
                OP_1ADD: number;
                OP_1NEGATE: number;
                OP_1SUB: number;
                OP_2: number;
                OP_2DIV: number;
                OP_2DROP: number;
                OP_2DUP: number;
                OP_2MUL: number;
                OP_2OVER: number;
                OP_2ROT: number;
                OP_2SWAP: number;
                OP_3: number;
                OP_3DUP: number;
                OP_4: number;
                OP_5: number;
                OP_6: number;
                OP_7: number;
                OP_8: number;
                OP_9: number;
                OP_ABS: number;
                OP_ADD: number;
                OP_AND: number;
                OP_BIN2NUM: number;
                OP_BOOLAND: number;
                OP_BOOLOR: number;
                OP_CAT: number;
                OP_CHECKDATASIG: number;
                OP_CHECKDATASIGVERIFY: number;
                OP_CHECKLOCKTIMEVERIFY: number;
                OP_CHECKMULTISIG: number;
                OP_CHECKMULTISIGVERIFY: number;
                OP_CHECKSEQUENCEVERIFY: number;
                OP_CHECKSIG: number;
                OP_CHECKSIGVERIFY: number;
                OP_CODESEPARATOR: number;
                OP_DEPTH: number;
                OP_DIV: number;
                OP_DROP: number;
                OP_DUP: number;
                OP_ELSE: number;
                OP_ENDIF: number;
                OP_EQUAL: number;
                OP_EQUALVERIFY: number;
                OP_FALSE: number;
                OP_FROMALTSTACK: number;
                OP_GREATERTHAN: number;
                OP_GREATERTHANOREQUAL: number;
                OP_HASH160: number;
                OP_HASH256: number;
                OP_IF: number;
                OP_IFDUP: number;
                OP_INVALIDOPCODE: number;
                OP_INVERT: number;
                OP_LESSTHAN: number;
                OP_LESSTHANOREQUAL: number;
                OP_LSHIFT: number;
                OP_MAX: number;
                OP_MIN: number;
                OP_MOD: number;
                OP_MUL: number;
                OP_NEGATE: number;
                OP_NIP: number;
                OP_NOP: number;
                OP_NOP1: number;
                OP_NOP10: number;
                OP_NOP2: number;
                OP_NOP3: number;
                OP_NOP4: number;
                OP_NOP5: number;
                OP_NOP6: number;
                OP_NOP7: number;
                OP_NOP8: number;
                OP_NOP9: number;
                OP_NOT: number;
                OP_NOTIF: number;
                OP_NUM2BIN: number;
                OP_NUMEQUAL: number;
                OP_NUMEQUALVERIFY: number;
                OP_NUMNOTEQUAL: number;
                OP_OR: number;
                OP_OVER: number;
                OP_PICK: number;
                OP_PREFIX_BEGIN: number;
                OP_PREFIX_END: number;
                OP_PUBKEY: number;
                OP_PUBKEYHASH: number;
                OP_PUBKEYS: number;
                OP_PUSHDATA1: number;
                OP_PUSHDATA2: number;
                OP_PUSHDATA4: number;
                OP_RESERVED: number;
                OP_RESERVED1: number;
                OP_RESERVED2: number;
                OP_RETURN: number;
                OP_RIPEMD160: number;
                OP_ROLL: number;
                OP_ROT: number;
                OP_RSHIFT: number;
                OP_SHA1: number;
                OP_SHA256: number;
                OP_SIZE: number;
                OP_SMALLINTEGER: number;
                OP_SPLIT: number;
                OP_SUB: number;
                OP_SWAP: number;
                OP_TOALTSTACK: number;
                OP_TRUE: number;
                OP_TUCK: number;
                OP_VER: number;
                OP_VERIF: number;
                OP_VERIFY: number;
                OP_VERNOTIF: number;
                OP_WITHIN: number;
                OP_XOR: number;
            };
            static reverseMap: string[];
            static smallInt(n: any): any;
            constructor(num: any);
            inspect(): any;
            toBuffer(): any;
            toHex(): any;
            toNumber(): any;
        }
        class PrivateKey {
            static fromBuffer(arg: any, network: any): any;
            static fromObject(obj: any): any;
            static fromRandom(network: any): any;
            static fromString(str: any): any;
            static fromWIF(str: any): any;
            static getValidationError(data: any, network: any): any;
            static isValid(data: any, network: any): any;
            constructor(data: any, network: any);
            inspect(): any;
            toAddress(network: any): any;
            toBigNumber(): any;
            toBuffer(): any;
            toBufferNoPadding(): any;
            toJSON(): any;
            toObject(): any;
            toPublicKey(): any;
            toWIF(): any;
        }
        class PublicKey {
            static fromBuffer(buf: any, strict: any): any;
            static fromDER(buf: any, strict: any): any;
            static fromPoint(point: any, compressed: any): any;
            static fromPrivateKey(privkey: any): any;
            static fromString(str: any, encoding: any): any;
            static fromX(odd: any, x: any): any;
            static getValidationError(data: any): any;
            static isValid(data: any): any;
            constructor(data: any, extra: any);
            inspect(): any;
            toAddress(network: any): any;
            toBuffer(): any;
            toDER(): any;
            toJSON(): any;
            toObject(): any;
        }
        class Script {
            static OP_RETURN_STANDARD_SIZE: number;
            static buildDataOut(data: any, encoding: any): any;
            static buildMultisigIn(pubkeys: any, threshold: any, signatures: any, opts: any): any;
            static buildMultisigOut(publicKeys: any, threshold: any, opts: any): any;
            static buildP2SHMultisigIn(pubkeys: any, threshold: any, signatures: any, opts: any): any;
            static buildPublicKeyHashIn(publicKey: any, signature: any, sigtype: any): any;
            static buildPublicKeyHashOut(to: any): any;
            static buildPublicKeyIn(signature: any, sigtype: any): any;
            static buildPublicKeyOut(pubkey: any): any;
            static buildScriptHashOut(script: any): any;
            static empty(): any;
            static fromASM(str: any): any;
            static fromAddress(address: any): any;
            static fromBuffer(buffer: any): any;
            static fromHex(str: any): any;
            static fromString(str: any): any;
            static types: {
                DATA_OUT: string;
                MULTISIG_IN: string;
                MULTISIG_OUT: string;
                PUBKEYHASH_IN: string;
                PUBKEYHASH_OUT: string;
                PUBKEY_IN: string;
                PUBKEY_OUT: string;
                SCRIPTHASH_IN: string;
                SCRIPTHASH_OUT: string;
                UNKNOWN: string;
            };
            constructor(from: any);
            chunks: any;
            add(obj: any): any;
            checkMinimalPush(i: any): any;
            classify(): any;
            classifyInput(): any;
            classifyOutput(): any;
            equals(script: any): any;
            findAndDelete(script: any): any;
            getAddressInfo(opts: any): any;
            getData(): any;
            getPublicKey(): any;
            getPublicKeyHash(): any;
            getSignatureOperationsCount(accurate: any): any;
            inspect(): any;
            isDataOut(): any;
            isMultisigIn(): any;
            isMultisigOut(): any;
            isPublicKeyHashIn(): any;
            isPublicKeyHashOut(): any;
            isPublicKeyIn(): any;
            isPublicKeyOut(): any;
            isPushOnly(): any;
            isScriptHashIn(): any;
            isScriptHashOut(): any;
            isStandard(): any;
            prepend(obj: any): any;
            removeCodeseparators(): any;
            set(obj: any): any;
            toASM(): any;
            toAddress(network: any): any;
            toBuffer(): any;
            toHex(): any;
            toScriptHashOut(): any;
        }
        namespace Script {
            class Interpreter {
                static LOCKTIME_THRESHOLD: number;
                static LOCKTIME_THRESHOLD_BN: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                static MAXIMUM_ELEMENT_SIZE: number;
                static MAX_SCRIPT_ELEMENT_SIZE: number;
                static SCRIPT_ENABLE_CHECKDATASIG: number;
                static SCRIPT_ENABLE_REPLAY_PROTECTION: number;
                static SCRIPT_ENABLE_SIGHASH_FORKID: number;
                static SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY: number;
                static SCRIPT_VERIFY_CHECKSEQUENCEVERIFY: number;
                static SCRIPT_VERIFY_CLEANSTACK: number;
                static SCRIPT_VERIFY_COMPRESSED_PUBKEYTYPE: number;
                static SCRIPT_VERIFY_DERSIG: number;
                static SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS: number;
                static SCRIPT_VERIFY_LOW_S: number;
                static SCRIPT_VERIFY_MINIMALDATA: number;
                static SCRIPT_VERIFY_MINIMALIF: number;
                static SCRIPT_VERIFY_NONE: number;
                static SCRIPT_VERIFY_NULLDUMMY: number;
                static SCRIPT_VERIFY_NULLFAIL: number;
                static SCRIPT_VERIFY_P2SH: number;
                static SCRIPT_VERIFY_SIGPUSHONLY: number;
                static SCRIPT_VERIFY_STRICTENC: number;
                static SEQUENCE_LOCKTIME_DISABLE_FLAG: number;
                static SEQUENCE_LOCKTIME_MASK: number;
                static SEQUENCE_LOCKTIME_TYPE_FLAG: number;
                static castToBool(buf: any): any;
                constructor(obj: any);
                checkDataSignatureEncoding(buf: any): any;
                checkLockTime(nLockTime: any): any;
                checkPubkeyEncoding(buf: any): any;
                checkRawSignatureEncoding(buf: any): any;
                checkSequence(nSequence: any): any;
                checkSignatureEncoding(buf: any): any;
                checkTxSignatureEncoding(buf: any): any;
                evaluate(): any;
                initialize(obj: any): void;
                set(obj: any): void;
                step(): any;
                verify(scriptSig: any, scriptPubkey: any, tx: any, nin: any, flags: any, satoshisBN: any): any;
            }
            namespace inputIdentifiers {
                function MULTISIG_IN(): any;
                function PUBKEYHASH_IN(): any;
                function PUBKEY_IN(): any;
                function SCRIPTHASH_IN(): any;
            }
            namespace outputIdentifiers {
                function DATA_OUT(): any;
                function MULTISIG_OUT(): any;
                function PUBKEYHASH_OUT(): any;
                function PUBKEY_OUT(): any;
                function SCRIPTHASH_OUT(): any;
            }
        }
        class Transaction {
            static CHANGE_OUTPUT_MAX_SIZE: number;
            static DUST_AMOUNT: number;
            static FEE_PER_KB: number;
            static FEE_SECURITY_MARGIN: number;
            static MAXIMUM_EXTRA_SIZE: number;
            static MAX_MONEY: number;
            static NLOCKTIME_BLOCKHEIGHT_LIMIT: number;
            static NLOCKTIME_MAX_VALUE: number;
            static shallowCopy(transaction: any): any;
            constructor(serialized: any);
            inputs: any;
            outputs: any;
            addData(value: any): any;
            addInput(input: any, outputScript: any, satoshis: any): any;
            addOutput(output: any): any;
            applySignature(signature: any): any;
            change(address: any): any;
            checkedSerialize(opts: any): any;
            clearOutputs(): any;
            fee(amount: any): any;
            feePerByte(amount: any): any;
            feePerKb(amount: any): any;
            from(utxo: any, pubkeys: any, threshold: any, opts: any): any;
            fromBuffer(buffer: any): any;
            fromBufferReader(reader: any): any;
            fromObject(arg: any): any;
            fromString(string: any): void;
            getChangeOutput(): any;
            getFee(): any;
            getLockTime(): any;
            getSerializationError(opts: any): any;
            getSignatures(privKey: any, sigtype: any): any;
            hasAllUtxoInfo(): any;
            inspect(): any;
            invalidSatoshis(): any;
            isCoinbase(): any;
            isFullySigned(): any;
            isValidSignature(signature: any): any;
            lockUntilBlockHeight(height: any): any;
            lockUntilDate(time: any): any;
            removeInput(txId: any, outputIndex: any): void;
            removeOutput(index: any): void;
            serialize(unsafe: any): any;
            shuffleOutputs(): any;
            sign(privateKey: any, sigtype: any): any;
            sort(): any;
            sortInputs(sortingFunction: any): any;
            sortOutputs(sortingFunction: any): any;
            to(address: any, amount: any): any;
            toBuffer(): any;
            toBufferWriter(writer: any): any;
            toJSON(): any;
            toObject(): any;
            uncheckedAddInput(input: any): any;
            uncheckedSerialize(): any;
            verify(): any;
            verifySignature(sig: any, pubkey: any, nin: any, subscript: any, satoshisBN: any, flags: any): any;
        }
        namespace Transaction {
            class Input {
                static DEFAULT_LOCKTIME_SEQNUMBER: number;
                static DEFAULT_RBF_SEQNUMBER: number;
                static DEFAULT_SEQNUMBER: number;
                static MAXINT: number;
                static fromBufferReader(br: any): any;
                static fromObject(obj: any): any;
                constructor(params: any);
                addSignature(): void;
                clearSignatures(): void;
                getSignatures(): void;
                isFinal(): any;
                isFullySigned(): void;
                isNull(): any;
                isValidSignature(transaction: any, signature: any): any;
                setScript(script: any): any;
                toBufferWriter(writer: any): any;
                toJSON(): any;
                toObject(): any;
            }
            namespace Input {
                class MultiSig {
                    // Too-deep object hierarchy from index.BitcoreCash.Transaction.Input.MultiSig
                    static OPCODES_SIZE: any;
                    // Too-deep object hierarchy from index.BitcoreCash.Transaction.Input.MultiSig
                    static SIGNATURE_SIZE: any;
                    // Too-deep object hierarchy from index.BitcoreCash.Transaction.Input.MultiSig
                    static normalizeSignatures: any;
                    constructor(input: any, pubkeys: any, threshold: any, signatures: any, opts: any, ...args: any[]);
                    publicKeys: any;
                    publicKeyIndex: any;
                    threshold: any;
                    signatures: any;
                }
                class MultiSigScriptHash {
                    // Too-deep object hierarchy from index.BitcoreCash.Transaction.Input.MultiSigScriptHash
                    static OPCODES_SIZE: any;
                    // Too-deep object hierarchy from index.BitcoreCash.Transaction.Input.MultiSigScriptHash
                    static PUBKEY_SIZE: any;
                    // Too-deep object hierarchy from index.BitcoreCash.Transaction.Input.MultiSigScriptHash
                    static SIGNATURE_SIZE: any;
                    constructor(input: any, pubkeys: any, threshold: any, signatures: any, opts: any, ...args: any[]);
                    publicKeys: any;
                    redeemScript: any;
                    publicKeyIndex: any;
                    threshold: any;
                    signatures: any;
                }
                function PublicKey(...args: any[]): void;
                namespace PublicKey {
                    // Too-deep object hierarchy from index.BitcoreCash.Transaction.Input.PublicKey
                    const SCRIPT_MAX_SIZE: any;
                }
                function PublicKeyHash(...args: any[]): void;
                namespace PublicKeyHash {
                    // Too-deep object hierarchy from index.BitcoreCash.Transaction.Input.PublicKeyHash
                    const SCRIPT_MAX_SIZE: any;
                }
            }
            class Output {
                static fromBufferReader(br: any): any;
                static fromObject(data: any): any;
                constructor(args: any);
                satoshis: any;
                inspect(): any;
                invalidSatoshis(): any;
                setScript(script: any): any;
                setScriptFromBuffer(buffer: any): void;
                toBufferWriter(writer: any): any;
                toJSON(): any;
                toObject(): any;
            }
            namespace Sighash {
                function sighash(transaction: any, sighashType: any, inputNumber: any, subscript: any, satoshisBN: any, flags: any): any;
                function sign(transaction: any, privateKey: any, sighashType: any, inputIndex: any, subscript: any, satoshisBN: any, flags: any): any;
                function verify(transaction: any, signature: any, publicKey: any, inputIndex: any, subscript: any, satoshisBN: any, flags: any): any;
            }
            class Signature {
                static fromObject(object: any): any;
                constructor(arg: any);
                hasDefinedHashtype(): any;
                hasLowS(): any;
                set(obj: any): any;
                toBuffer(): any;
                toCompact(i: any, compressed: any): any;
                toDER(): any;
                toJSON(): any;
                toObject(): any;
                toTxFormat(): any;
            }
            class UnspentOutput {
                static fromObject(data: any): any;
                constructor(data: any);
                inspect(): any;
                toJSON(): any;
                toObject(): any;
            }
            namespace sighash {
                function sighash(transaction: any, sighashType: any, inputNumber: any, subscript: any, satoshisBN: any, flags: any): any;
                function sign(transaction: any, privateKey: any, sighashType: any, inputIndex: any, subscript: any, satoshisBN: any, flags: any): any;
                function verify(transaction: any, signature: any, publicKey: any, inputIndex: any, subscript: any, satoshisBN: any, flags: any): any;
            }
        }
        class URI {
            static Members: string[];
            static fromObject(json: any): any;
            static fromString(str: any): any;
            static isValid(arg: any, knownParams: any): any;
            static parse(uri: any): any;
            constructor(data: any, knownParams: any);
            extras: any;
            knownParams: any;
            address: any;
            network: any;
            amount: any;
            message: any;
            inspect(): any;
            toJSON(): any;
            toObject(): any;
        }
        class Unit {
            static BTC: string;
            static bits: string;
            static fromBTC(amount: any): any;
            static fromBits(amount: any): any;
            static fromFiat(amount: any, rate: any): any;
            static fromMicros(amount: any): any;
            static fromMilis(amount: any): any;
            static fromMillis(amount: any): any;
            static fromObject(data: any): any;
            static fromSatoshis(amount: any): any;
            static mBTC: string;
            static satoshis: string;
            static uBTC: string;
            constructor(amount: any, code: any);
            atRate(rate: any): any;
            inspect(): any;
            to(code: any): any;
            toBTC(): any;
            toBits(): any;
            toJSON(): any;
            toMicros(): any;
            toMilis(): any;
            toMillis(): any;
            toObject(): any;
            toSatoshis(): any;
        }
        namespace crypto {
            class BN {
                // Circular reference from index.BitcoreCash.crypto.BN
                static BN: any;
                static Minus1: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                static One: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                static Zero: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                static fromBuffer(buf: any, opts: any): any;
                static fromNumber(n: any): any;
                static fromSM(buf: any, opts: any): any;
                static fromScriptNumBuffer(buf: any, fRequireMinimal: any, size: any): any;
                static fromString(str: any, base: any): any;
                static isBN(num: any): any;
                static max(left: any, right: any): any;
                static min(left: any, right: any): any;
                static mont(num: any): any;
                static pad(buf: any, natlen: any, size: any): any;
                static red(num: any): any;
                static trim(buf: any, natlen: any): any;
                static wordSize: number;
                constructor(number: any, base: any, endian: any);
                negative: any;
                words: any;
                length: any;
                red: any;
                abs(): any;
                add(num: any): any;
                addn(num: any): any;
                and(num: any): any;
                andln(num: any): any;
                bincn(bit: any): any;
                bitLength(): any;
                byteLength(): any;
                clone(): any;
                cmp(num: any): any;
                cmpn(num: any): any;
                copy(dest: any): void;
                div(num: any): any;
                divRound(num: any): any;
                divmod(num: any, mode: any, positive: any): any;
                divn(num: any): any;
                egcd(p: any): any;
                eq(num: any): any;
                eqn(num: any): any;
                forceRed(ctx: any): any;
                fromRed(): any;
                fromTwos(width: any): any;
                gcd(num: any): any;
                gt(num: any): any;
                gte(num: any): any;
                gten(num: any): any;
                gtn(num: any): any;
                iabs(): any;
                iadd(num: any): any;
                iaddn(num: any): any;
                iand(num: any): any;
                idivn(num: any): any;
                imaskn(bits: any): any;
                imul(num: any): any;
                imuln(num: any): any;
                ineg(): any;
                inotn(width: any): any;
                inspect(): any;
                invm(num: any): any;
                ior(num: any): any;
                isEven(): any;
                isNeg(): any;
                isOdd(): any;
                isZero(): any;
                ishln(bits: any): any;
                ishrn(bits: any, hint: any, extended: any): any;
                isqr(): any;
                isub(num: any): any;
                isubn(num: any): any;
                iuand(num: any): any;
                iuor(num: any): any;
                iushln(bits: any): any;
                iushrn(bits: any, hint: any, extended: any): any;
                iuxor(num: any): any;
                ixor(num: any): any;
                lt(num: any): any;
                lte(num: any): any;
                lten(num: any): any;
                ltn(num: any): any;
                maskn(bits: any): any;
                mod(num: any): any;
                modn(num: any): any;
                mul(num: any): any;
                mulTo(num: any, out: any): any;
                mulf(num: any): any;
                muln(num: any): any;
                neg(): any;
                notn(width: any): any;
                or(num: any): any;
                pow(num: any): any;
                redAdd(num: any): any;
                redIAdd(num: any): any;
                redIMul(num: any): any;
                redISqr(): any;
                redISub(num: any): any;
                redInvm(): any;
                redMul(num: any): any;
                redNeg(): any;
                redPow(num: any): any;
                redShl(num: any): any;
                redSqr(): any;
                redSqrt(): any;
                redSub(num: any): any;
                setn(bit: any, val: any): any;
                shln(bits: any): any;
                shrn(bits: any): any;
                sqr(): any;
                strip(): any;
                sub(num: any): any;
                subn(num: any): any;
                testn(bit: any): any;
                toArray(endian: any, length: any): any;
                toArrayLike(ArrayType: any, endian: any, length: any): any;
                toBuffer(opts: any): any;
                toJSON(): any;
                toNumber(): any;
                toRed(ctx: any): any;
                toSM(opts: any): any;
                toSMBigEndian(): any;
                toScriptNumBuffer(): any;
                toString(base: any, padding: any): any;
                toTwos(width: any): any;
                uand(num: any): any;
                ucmp(num: any): any;
                umod(num: any): any;
                uor(num: any): any;
                ushln(bits: any): any;
                ushrn(bits: any): any;
                uxor(num: any): any;
                xor(num: any): any;
                zeroBits(): any;
            }
            class ECDSA {
                static fromString(str: any): any;
                static sign(hashbuf: any, privkey: any, endian: any): any;
                static toLowS(s: any): any;
                static verify(hashbuf: any, sig: any, pubkey: any, endian: any): any;
                constructor(obj: any);
                calci(): any;
                deterministicK(badrs: any): any;
                privkey2pubkey(): void;
                randomK(): any;
                set(obj: any): any;
                sigError(): any;
                sign(): any;
                signRandomK(): any;
                toPublicKey(): any;
                verify(): any;
            }
            namespace Hash {
                function hmac(hashf: any, data: any, key: any): any;
                function ripemd160(buf: any): any;
                function sha1(buf: any): any;
                namespace sha1 {
                    // Too-deep object hierarchy from index.BitcoreCash.crypto.Hash.sha1
                    const blocksize: any;
                }
                function sha256(buf: any): any;
                namespace sha256 {
                    // Too-deep object hierarchy from index.BitcoreCash.crypto.Hash.sha256
                    const blocksize: any;
                }
                function sha256hmac(data: any, key: any): any;
                function sha256ripemd160(buf: any): any;
                function sha256sha256(buf: any): any;
                function sha512(buf: any): any;
                namespace sha512 {
                    // Too-deep object hierarchy from index.BitcoreCash.crypto.Hash.sha512
                    const blocksize: any;
                }
                function sha512hmac(data: any, key: any): any;
            }
            class Point {
                static fromX(odd: any, x: any): any;
                static getG(): any;
                static getN(): any;
                static pointToCompressed(point: any): any;
                constructor(x: any, y: any, isRed: any);
                add(p: any): any;
                dbl(): any;
                dblp(k: any): any;
                encode(enc: any, compact: any): any;
                encodeCompressed(enc: any): any;
                eq(p: any): any;
                getX(): any;
                getY(): any;
                inspect(): any;
                isInfinity(): any;
                jmulAdd(k1: any, p2: any, k2: any): any;
                mul(k: any): any;
                mulAdd(k1: any, p2: any, k2: any): any;
                neg(_precompute: any): any;
                precompute(power: any): any;
                toJ(): any;
                toJSON(): any;
                validate(): any;
            }
            function Random(): void;
            namespace Random {
                function getPseudoRandomBuffer(size: any): any;
                function getRandomBuffer(size: any): any;
                function getRandomBufferBrowser(size: any): any;
                function getRandomBufferNode(size: any): any;
            }
            class Signature {
                static SIGHASH_ALL: number;
                static SIGHASH_ANYONECANPAY: number;
                static SIGHASH_FORKID: number;
                static SIGHASH_NONE: number;
                static SIGHASH_SINGLE: number;
                static fromBuffer(buf: any, strict: any): any;
                static fromCompact(buf: any): any;
                static fromDER(buf: any, strict: any): any;
                static fromDataFormat(buf: any): any;
                static fromString(str: any): any;
                static fromTxFormat(buf: any): any;
                static isDER(buf: any): any;
                static isTxDER(buf: any): any;
                static parseDER(buf: any, strict: any): any;
                constructor(r: any, s: any);
                hasDefinedHashtype(): any;
                hasLowS(): any;
                set(obj: any): any;
                toBuffer(): any;
                toCompact(i: any, compressed: any): any;
                toDER(): any;
                toTxFormat(): any;
            }
        }
        namespace deps {
            class Buffer {
                static BYTES_PER_ELEMENT: number;
                static alloc(size: any, fill: any, encoding: any): any;
                static allocUnsafe(size: any): any;
                static allocUnsafeSlow(size: any): any;
                static byteLength(string: any, encoding: any, ...args: any[]): any;
                static compare(buf1: any, buf2: any): any;
                static concat(list: any, length: any): any;
                static from(value: any, encodingOrOffset: any, length: any): any;
                static isBuffer(b: any): any;
                static isEncoding(encoding: any): any;
                static of(items: any): any;
                static poolSize: number;
                constructor(arg: any, encodingOrOffset: any, length: any);
                asciiSlice(): any;
                asciiWrite(): any;
                base64Slice(): any;
                base64Write(): any;
                compare(target: any, start: any, end: any, thisStart: any, thisEnd: any, ...args: any[]): any;
                copy(target: any, targetStart: any, sourceStart: any, sourceEnd: any): any;
                copyWithin(p0: any, p1: any): any;
                entries(): any;
                equals(otherBuffer: any): any;
                every(p0: any): any;
                fill(val: any, start: any, end: any, encoding: any): any;
                filter(p0: any): any;
                find(p0: any): any;
                findIndex(p0: any): any;
                forEach(p0: any): any;
                hexSlice(): any;
                hexWrite(): any;
                includes(val: any, byteOffset: any, encoding: any): any;
                indexOf(val: any, byteOffset: any, encoding: any): any;
                inspect(): any;
                join(p0: any): any;
                keys(): any;
                lastIndexOf(val: any, byteOffset: any, encoding: any): any;
                latin1Slice(): any;
                latin1Write(): any;
                map(p0: any): any;
                readDoubleBE(offset: any): any;
                readDoubleLE(offset: any): any;
                readFloatBE(offset: any): any;
                readFloatLE(offset: any): any;
                readInt16BE(offset: any): any;
                readInt16LE(offset: any): any;
                readInt32BE(offset: any): any;
                readInt32LE(offset: any): any;
                readInt8(offset: any): any;
                readIntBE(offset: any, byteLength: any): any;
                readIntLE(offset: any, byteLength: any): any;
                readUInt16BE(offset: any): any;
                readUInt16LE(offset: any): any;
                readUInt32BE(offset: any): any;
                readUInt32LE(offset: any): any;
                readUInt8(offset: any): any;
                readUIntBE(offset: any, byteLength: any): any;
                readUIntLE(offset: any, byteLength: any): any;
                reduce(p0: any): any;
                reduceRight(p0: any): any;
                reverse(): any;
                set(p0: any): any;
                slice(start: any, end: any): any;
                some(p0: any): any;
                sort(p0: any): any;
                subarray(p0: any, p1: any): any;
                swap16(): any;
                swap32(): any;
                swap64(): any;
                toJSON(): any;
                toLocaleString(encoding: any, start: any, end: any, ...args: any[]): any;
                toString(encoding: any, start: any, end: any, ...args: any[]): any;
                ucs2Slice(): any;
                ucs2Write(): any;
                utf8Slice(): any;
                utf8Write(): any;
                values(): any;
                write(string: any, offset: any, length: any, encoding: any): any;
                writeDoubleBE(val: any, offset: any): any;
                writeDoubleLE(val: any, offset: any): any;
                writeFloatBE(val: any, offset: any): any;
                writeFloatLE(val: any, offset: any): any;
                writeInt16BE(value: any, offset: any): any;
                writeInt16LE(value: any, offset: any): any;
                writeInt32BE(value: any, offset: any): any;
                writeInt32LE(value: any, offset: any): any;
                writeInt8(value: any, offset: any): any;
                writeIntBE(value: any, offset: any, byteLength: any): any;
                writeIntLE(value: any, offset: any, byteLength: any): any;
                writeUInt16BE(value: any, offset: any): any;
                writeUInt16LE(value: any, offset: any): any;
                writeUInt32BE(value: any, offset: any): any;
                writeUInt32LE(value: any, offset: any): any;
                writeUInt8(value: any, offset: any): any;
                writeUIntBE(value: any, offset: any, byteLength: any): any;
                writeUIntLE(value: any, offset: any, byteLength: any): any;
            }
            class bnjs {
                // Circular reference from index.BitcoreCash.deps.bnjs
                static BN: any;
                static Minus1: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                static One: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                static Zero: {
                    abs: any;
                    add: any;
                    addn: any;
                    and: any;
                    andln: any;
                    bincn: any;
                    bitLength: any;
                    byteLength: any;
                    clone: any;
                    cmp: any;
                    cmpn: any;
                    copy: any;
                    div: any;
                    divRound: any;
                    divmod: any;
                    divn: any;
                    egcd: any;
                    eq: any;
                    eqn: any;
                    forceRed: any;
                    fromRed: any;
                    fromTwos: any;
                    gcd: any;
                    gt: any;
                    gte: any;
                    gten: any;
                    gtn: any;
                    iabs: any;
                    iadd: any;
                    iaddn: any;
                    iand: any;
                    idivn: any;
                    imaskn: any;
                    imul: any;
                    imuln: any;
                    ineg: any;
                    inotn: any;
                    inspect: any;
                    invm: any;
                    ior: any;
                    isEven: any;
                    isNeg: any;
                    isOdd: any;
                    isZero: any;
                    ishln: any;
                    ishrn: any;
                    isqr: any;
                    isub: any;
                    isubn: any;
                    iuand: any;
                    iuor: any;
                    iushln: any;
                    iushrn: any;
                    iuxor: any;
                    ixor: any;
                    length: any;
                    lt: any;
                    lte: any;
                    lten: any;
                    ltn: any;
                    maskn: any;
                    mod: any;
                    modn: any;
                    mul: any;
                    mulTo: any;
                    mulf: any;
                    muln: any;
                    neg: any;
                    negative: any;
                    notn: any;
                    or: any;
                    pow: any;
                    red: any;
                    redAdd: any;
                    redIAdd: any;
                    redIMul: any;
                    redISqr: any;
                    redISub: any;
                    redInvm: any;
                    redMul: any;
                    redNeg: any;
                    redPow: any;
                    redShl: any;
                    redSqr: any;
                    redSqrt: any;
                    redSub: any;
                    setn: any;
                    shln: any;
                    shrn: any;
                    sqr: any;
                    strip: any;
                    sub: any;
                    subn: any;
                    testn: any;
                    toArray: any;
                    toArrayLike: any;
                    toBuffer: any;
                    toJSON: any;
                    toNumber: any;
                    toRed: any;
                    toSM: any;
                    toSMBigEndian: any;
                    toScriptNumBuffer: any;
                    toString: any;
                    toTwos: any;
                    uand: any;
                    ucmp: any;
                    umod: any;
                    uor: any;
                    ushln: any;
                    ushrn: any;
                    uxor: any;
                    words: any;
                    xor: any;
                    zeroBits: any;
                };
                static fromBuffer(buf: any, opts: any): any;
                static fromNumber(n: any): any;
                static fromSM(buf: any, opts: any): any;
                static fromScriptNumBuffer(buf: any, fRequireMinimal: any, size: any): any;
                static fromString(str: any, base: any): any;
                static isBN(num: any): any;
                static max(left: any, right: any): any;
                static min(left: any, right: any): any;
                static mont(num: any): any;
                static pad(buf: any, natlen: any, size: any): any;
                static red(num: any): any;
                static trim(buf: any, natlen: any): any;
                static wordSize: number;
                constructor(number: any, base: any, endian: any);
                negative: any;
                words: any;
                length: any;
                red: any;
                abs(): any;
                add(num: any): any;
                addn(num: any): any;
                and(num: any): any;
                andln(num: any): any;
                bincn(bit: any): any;
                bitLength(): any;
                byteLength(): any;
                clone(): any;
                cmp(num: any): any;
                cmpn(num: any): any;
                copy(dest: any): void;
                div(num: any): any;
                divRound(num: any): any;
                divmod(num: any, mode: any, positive: any): any;
                divn(num: any): any;
                egcd(p: any): any;
                eq(num: any): any;
                eqn(num: any): any;
                forceRed(ctx: any): any;
                fromRed(): any;
                fromTwos(width: any): any;
                gcd(num: any): any;
                gt(num: any): any;
                gte(num: any): any;
                gten(num: any): any;
                gtn(num: any): any;
                iabs(): any;
                iadd(num: any): any;
                iaddn(num: any): any;
                iand(num: any): any;
                idivn(num: any): any;
                imaskn(bits: any): any;
                imul(num: any): any;
                imuln(num: any): any;
                ineg(): any;
                inotn(width: any): any;
                inspect(): any;
                invm(num: any): any;
                ior(num: any): any;
                isEven(): any;
                isNeg(): any;
                isOdd(): any;
                isZero(): any;
                ishln(bits: any): any;
                ishrn(bits: any, hint: any, extended: any): any;
                isqr(): any;
                isub(num: any): any;
                isubn(num: any): any;
                iuand(num: any): any;
                iuor(num: any): any;
                iushln(bits: any): any;
                iushrn(bits: any, hint: any, extended: any): any;
                iuxor(num: any): any;
                ixor(num: any): any;
                lt(num: any): any;
                lte(num: any): any;
                lten(num: any): any;
                ltn(num: any): any;
                maskn(bits: any): any;
                mod(num: any): any;
                modn(num: any): any;
                mul(num: any): any;
                mulTo(num: any, out: any): any;
                mulf(num: any): any;
                muln(num: any): any;
                neg(): any;
                notn(width: any): any;
                or(num: any): any;
                pow(num: any): any;
                redAdd(num: any): any;
                redIAdd(num: any): any;
                redIMul(num: any): any;
                redISqr(): any;
                redISub(num: any): any;
                redInvm(): any;
                redMul(num: any): any;
                redNeg(): any;
                redPow(num: any): any;
                redShl(num: any): any;
                redSqr(): any;
                redSqrt(): any;
                redSub(num: any): any;
                setn(bit: any, val: any): any;
                shln(bits: any): any;
                shrn(bits: any): any;
                sqr(): any;
                strip(): any;
                sub(num: any): any;
                subn(num: any): any;
                testn(bit: any): any;
                toArray(endian: any, length: any): any;
                toArrayLike(ArrayType: any, endian: any, length: any): any;
                toBuffer(opts: any): any;
                toJSON(): any;
                toNumber(): any;
                toRed(ctx: any): any;
                toSM(opts: any): any;
                toSMBigEndian(): any;
                toScriptNumBuffer(): any;
                toString(base: any, padding: any): any;
                toTwos(width: any): any;
                uand(num: any): any;
                ucmp(num: any): any;
                umod(num: any): any;
                uor(num: any): any;
                ushln(bits: any): any;
                ushrn(bits: any): any;
                uxor(num: any): any;
                xor(num: any): any;
                zeroBits(): any;
            }
            namespace bs58 {
                function decode(string: any): any;
                function decodeUnsafe(source: any): any;
                function encode(source: any): any;
            }
            namespace elliptic {
                const curve: {
                    base: any;
                    edwards: any;
                    mont: any;
                    short: any;
                };
                const curves: {
                    PresetCurve: any;
                    curve25519: any;
                    ed25519: any;
                    p192: any;
                    p224: any;
                    p256: any;
                    p384: any;
                    p521: any;
                    secp256k1: any;
                };
                class ec {
                    constructor(options: any);
                    curve: any;
                    n: any;
                    nh: any;
                    g: any;
                    hash: any;
                }
                class eddsa {
                    constructor(curve: any);
                    curve: any;
                    g: any;
                    pointClass: any;
                    encodingLength: any;
                    hash: any;
                }
                function rand(len: any): any;
                namespace rand {
                    // Too-deep object hierarchy from index.BitcoreCash.deps.elliptic.rand
                    const Rand: any;
                }
                const utils: {
                    assert: any;
                    cachedProperty: any;
                    encode: any;
                    getJSF: any;
                    getNAF: any;
                    intFromLE: any;
                    parseBytes: any;
                    toArray: any;
                    toHex: any;
                    zero2: any;
                };
                const version: string;
            }
        }
        namespace encoding {
            class Base58 {
                static decode(str: any): any;
                static encode(buf: any): any;
                static validCharacters(chars: any): any;
                constructor(obj: any);
                fromBuffer(buf: any): any;
                fromString(str: any): any;
                set(obj: any): any;
                toBuffer(): any;
            }
            class Base58Check {
                static checksum(buffer: any): any;
                static decode(s: any): any;
                static encode(buf: any): any;
                static validChecksum(data: any, checksum: any): any;
                constructor(obj: any);
                fromBuffer(buf: any): any;
                fromString(str: any): any;
                set(obj: any): any;
                toBuffer(): any;
            }
            class BufferReader {
                constructor(buf: any);
                eof(): any;
                finished(): any;
                read(len: any): any;
                readAll(): any;
                readInt32LE(): any;
                readReverse(len: any): any;
                readUInt16BE(): any;
                readUInt16LE(): any;
                readUInt32BE(): any;
                readUInt32LE(): any;
                readUInt64BEBN(): any;
                readUInt64LEBN(): any;
                readUInt8(): any;
                readVarLengthBuffer(): any;
                readVarintBN(): any;
                readVarintBuf(): any;
                readVarintNum(): any;
                reverse(): any;
                set(obj: any): any;
            }
            class BufferWriter {
                static varintBufBN(bn: any): any;
                static varintBufNum(n: any): any;
                constructor(obj: any);
                bufLen: any;
                bufs: any;
                concat(): any;
                set(obj: any): any;
                toBuffer(): any;
                write(buf: any): any;
                writeInt32LE(n: any): any;
                writeReverse(buf: any): any;
                writeUInt16BE(n: any): any;
                writeUInt16LE(n: any): any;
                writeUInt32BE(n: any): any;
                writeUInt32LE(n: any): any;
                writeUInt64BEBN(bn: any): any;
                writeUInt64LEBN(bn: any): any;
                writeUInt8(n: any): any;
                writeVarintBN(bn: any): any;
                writeVarintNum(n: any): any;
            }
            class Varint {
                constructor(buf: any);
                buf: any;
                fromBN(bn: any): any;
                fromBuffer(buf: any): any;
                fromBufferReader(br: any): any;
                fromNumber(num: any): any;
                fromString(str: any): any;
                set(obj: any): any;
                toBN(): any;
                toBuffer(): any;
                toNumber(): any;
            }
        }
        class errors {
            static AbstractMethodInvoked(...args: any[]): void;
            static InvalidArgument(...args: any[]): void;
            static InvalidArgumentType(...args: any[]): void;
            static InvalidB58Char(...args: any[]): void;
            static InvalidB58Checksum(...args: any[]): void;
            static InvalidNetwork(...args: any[]): void;
            static InvalidNetworkArgument(...args: any[]): void;
            static InvalidState(...args: any[]): void;
            static NotImplemented(...args: any[]): void;
            static extend(spec: any): any;
            message: any;
            stack: any;
        }
        namespace errors {
            class HDPrivateKey {
                static InvalidDerivationArgument(...args: any[]): void;
                static InvalidLength(...args: any[]): void;
                static InvalidPath(...args: any[]): void;
                static UnrecognizedArgument(...args: any[]): void;
                constructor(...args: any[]);
                message: any;
                stack: any;
            }
            namespace HDPrivateKey {
                class InvalidEntropyArgument {
                    // Too-deep object hierarchy from index.BitcoreCash.errors.HDPrivateKey.InvalidEntropyArgument
                    static NotEnoughEntropy: any;
                    // Too-deep object hierarchy from index.BitcoreCash.errors.HDPrivateKey.InvalidEntropyArgument
                    static TooMuchEntropy: any;
                    constructor(...args: any[]);
                    message: any;
                    stack: any;
                }
            }
            class HDPublicKey {
                static ArgumentIsPrivateExtended(...args: any[]): void;
                static InvalidDerivationArgument(...args: any[]): void;
                static InvalidIndexCantDeriveHardened(...args: any[]): void;
                static InvalidLength(...args: any[]): void;
                static InvalidPath(...args: any[]): void;
                static MustSupplyArgument(...args: any[]): void;
                static UnrecognizedArgument(...args: any[]): void;
                constructor(...args: any[]);
                message: any;
                stack: any;
            }
            class MerkleBlock {
                static InvalidMerkleTree(...args: any[]): void;
                constructor(...args: any[]);
                message: any;
                stack: any;
            }
            class Script {
                static CantDeriveAddress(...args: any[]): void;
                static InvalidBuffer(...args: any[]): void;
                static UnrecognizedAddress(...args: any[]): void;
                constructor(...args: any[]);
                message: any;
                stack: any;
            }
            class Transaction {
                static BlockHeightTooHigh(...args: any[]): void;
                static ChangeAddressMissing(...args: any[]): void;
                static DustOutputs(...args: any[]): void;
                static InvalidIndex(...args: any[]): void;
                static InvalidOutputAmountSum(...args: any[]): void;
                static InvalidSatoshis(...args: any[]): void;
                static InvalidSorting(...args: any[]): void;
                static LockTimeTooEarly(...args: any[]): void;
                static MissingSignatures(...args: any[]): void;
                static NLockTimeOutOfRange(...args: any[]): void;
                static NeedMoreInfo(...args: any[]): void;
                static UnableToVerifySignature(...args: any[]): void;
                constructor(...args: any[]);
                message: any;
                stack: any;
            }
            namespace Transaction {
                class FeeError {
                    // Too-deep object hierarchy from index.BitcoreCash.errors.Transaction.FeeError
                    static Different: any;
                    // Too-deep object hierarchy from index.BitcoreCash.errors.Transaction.FeeError
                    static TooLarge: any;
                    // Too-deep object hierarchy from index.BitcoreCash.errors.Transaction.FeeError
                    static TooSmall: any;
                    constructor(...args: any[]);
                    message: any;
                    stack: any;
                }
                class Input {
                    // Too-deep object hierarchy from index.BitcoreCash.errors.Transaction.Input
                    static MissingPreviousOutput: any;
                    // Too-deep object hierarchy from index.BitcoreCash.errors.Transaction.Input
                    static MissingScript: any;
                    // Too-deep object hierarchy from index.BitcoreCash.errors.Transaction.Input
                    static UnsupportedScript: any;
                    constructor(...args: any[]);
                    message: any;
                    stack: any;
                }
            }
            class Unit {
                static InvalidRate(...args: any[]): void;
                static UnknownCode(...args: any[]): void;
                constructor(...args: any[]);
                message: any;
                stack: any;
            }
        }
        namespace util {
            namespace base32 {
                function decode(base32: any): any;
                function encode(data: any): any;
            }
            namespace buffer {
                const EMPTY_BUFFER: Buffer;
                const NULL_HASH: Buffer;
                function bufferToHex(buffer: any): any;
                function concat(list: any, length: any): any;
                function copy(original: any): any;
                function emptyBuffer(bytes: any): any;
                function equal(a: any, b: any): any;
                function equals(a: any, b: any): any;
                function fill(buffer: any, value: any): any;
                function hexToBuffer(string: any): any;
                function integerAsBuffer(integer: any): any;
                function integerAsSingleByteBuffer(integer: any): any;
                function integerFromBuffer(buffer: any): any;
                function integerFromSingleByteBuffer(buffer: any): any;
                function isBuffer(arg: any): any;
                function reverse(param: any): any;
            }
            function convertBits(data: any, from: any, to: any, strict: any): any;
            namespace js {
                function cloneArray(array: any): any;
                function defineImmutable(target: any, values: any): any;
                function isHexa(value: any): any;
                function isHexaString(value: any): any;
                function isNaturalNumber(value: any): any;
                function isValidJSON(arg: any): any;
            }
            namespace preconditions {
                function checkArgument(condition: any, argumentName: any, message: any, docsPath: any): void;
                function checkArgumentType(argument: any, type: any, argumentName: any): void;
                function checkState(condition: any, message: any): void;
            }
        }
        const version: string;
        function versionGuard(version: any): void;
    }
    namespace PayPro {
        function get(opts: any, cb: any): void;
        function request(uri: any, options: any, callback: any): any;
        namespace request {
            class Request {
                static debug: any;
                static defaultProxyHeaderExclusiveList: any[];
                static defaultProxyHeaderWhiteList: any[];
                constructor(options: any);
                abort(): void;
                addListener(type: any, listener: any): any;
                auth(user: any, pass: any, sendImmediately: any, bearer: any): any;
                aws(opts: any, now: any): any;
                debug(...args: any[]): void;
                destroy(): void;
                emit(type: any, args: any): any;
                enableUnixSocket(): void;
                end(chunk: any): void;
                eventNames(): any;
                form(form: any): any;
                getHeader(name: any, headers: any): any;
                getMaxListeners(): any;
                getNewAgent(): any;
                hawk(opts: any): void;
                httpSignature(opts: any): any;
                init(options: any): any;
                jar(jar: any): any;
                json(val: any): any;
                listenerCount(type: any): any;
                listeners(type: any): any;
                multipart(multipart: any): any;
                oauth(_oauth: any): any;
                off(type: any, listener: any): any;
                on(type: any, listener: any): any;
                onRequestError(error: any): void;
                onRequestResponse(response: any): void;
                once(type: any, listener: any): any;
                pause(...args: any[]): void;
                pipe(dest: any, opts: any): any;
                pipeDest(dest: any): void;
                prependListener(type: any, listener: any): any;
                prependOnceListener(type: any, listener: any): any;
                qs(q: any, clobber: any): any;
                rawListeners(type: any): any;
                readResponseBody(response: any): void;
                removeAllListeners(type: any, ...args: any[]): any;
                removeListener(type: any, listener: any): any;
                resume(...args: any[]): void;
                setMaxListeners(n: any): any;
                start(): void;
                toJSON(): any;
                write(...args: any[]): any;
            }
            function cookie(str: any): any;
            const debug: any;
            function defaults(options: any, requester: any): any;
            function del(uri: any, options: any, callback: any): any;
            function forever(agentOptions: any, optionsArg: any): any;
            function get(uri: any, options: any, callback: any): any;
            function head(uri: any, options: any, callback: any): any;
            function initParams(uri: any, options: any, callback: any): any;
            function jar(store: any): any;
            function options(uri: any, options: any, callback: any): any;
            function patch(uri: any, options: any, callback: any): any;
            function post(uri: any, options: any, callback: any): any;
            function put(uri: any, options: any, callback: any): any;
        }
        function runRequest(opts: any, cb: any): void;
        function send(opts: any, cb: any): void;
    }
    function Utils(): void;
    namespace Utils {
        const SJCL: {};
        function buildTx(txp: any): any;
        function decryptMessage(cyphertextJson: any, encryptingKey: any): any;
        function decryptMessageNoThrow(cyphertextJson: any, encryptingKey: any): any;
        function deriveAddress(scriptType: any, publicKeyRing: any, path: any, m: any, network: any, coin: any): any;
        function encryptMessage(message: any, encryptingKey: any): any;
        function formatAmount(satoshis: any, unit: any, opts: any): any;
        function getCopayerHash(name: any, xPubKey: any, requestPubKey: any): any;
        function getProposalHash(proposalHeader: any, ...args: any[]): any;
        function hashMessage(text: any): any;
        function privateKeyToAESKey(privKey: any): any;
        function signMessage(text: any, privKey: any): any;
        function signRequestPubKey(requestPubKey: any, xPrivKey: any): any;
        function verifyMessage(text: any, signature: any, pubKey: any): any;
        function verifyRequestPubKey(requestPubKey: any, signature: any, xPubKey: any): any;
        function xPubToCopayerId(coin: any, xpub: any): any;
    }
    function Verifier(opts: any): void;
    namespace Verifier {
        function checkAddress(credentials: any, address: any): any;
        function checkCopayers(credentials: any, copayers: any): any;
        function checkPaypro(txp: any, payproOpts: any): any;
        function checkProposalCreation(args: any, txp: any, encryptingKey: any): any;
        function checkTxProposal(credentials: any, txp: any, opts: any): any;
        function checkTxProposalSignature(credentials: any, txp: any): any;
    }
    class errors {
        static CONNECTION_ERROR(...args: any[]): void;
        static COPAYER_IN_WALLET(...args: any[]): void;
        static COPAYER_REGISTERED(...args: any[]): void;
        static COPAYER_VOTED(...args: any[]): void;
        static COULD_NOT_BUILD_TRANSACTION(...args: any[]): void;
        static DUST_AMOUNT(...args: any[]): void;
        static ECONNRESET_ERROR(...args: any[]): void;
        static ENCRYPTED_PRIVATE_KEY(...args: any[]): void;
        static INSUFFICIENT_FUNDS(...args: any[]): void;
        static INSUFFICIENT_FUNDS_FOR_FEE(...args: any[]): void;
        static INVALID_BACKUP(...args: any[]): void;
        static INVOICE_EXPIRED(...args: any[]): void;
        static INVOICE_NOT_AVAILABLE(...args: any[]): void;
        static LOCKED_FUNDS(...args: any[]): void;
        static MAIN_ADDRESS_GAP_REACHED(...args: any[]): void;
        static MISSING_PRIVATE_KEY(...args: any[]): void;
        static NOT_AUTHORIZED(...args: any[]): void;
        static NOT_FOUND(...args: any[]): void;
        static SERVER_COMPROMISED(...args: any[]): void;
        static TX_NOT_FOUND(...args: any[]): void;
        static UNAVAILABLE_UTXOS(...args: any[]): void;
        static UNCONFIRMED_INPUTS_NOT_ACCEPTED(...args: any[]): void;
        static WALLET_ALREADY_EXISTS(...args: any[]): void;
        static WALLET_DOES_NOT_EXIST(...args: any[]): void;
        static WALLET_FULL(...args: any[]): void;
        static WALLET_NOT_FOUND(...args: any[]): void;
        static extend(spec: any): any;
        message: any;
        stack: any;
    }
    namespace sjcl {
        namespace bitArray {
            function P(a: any, b: any, c: any, d: any): any;
            function bitLength(a: any): any;
            function bitSlice(a: any, b: any, c: any): any;
            function byteswapM(a: any): any;
            function clamp(a: any, b: any): any;
            function concat(a: any, b: any): any;
            function equal(a: any, b: any): any;
            function extract(a: any, b: any, c: any): any;
            function getPartial(a: any): any;
            function l(a: any, b: any): any;
            function partial(a: any, b: any, c: any): any;
        }
        namespace cipher {
            class aes {
                constructor(a: any);
                b: any;
                D(): void;
                decrypt(a: any): any;
                encrypt(a: any): any;
            }
        }
        const codec: {
            base64: {
                J: string;
                fromBits: Function;
                toBits: Function;
            };
            base64url: {
                fromBits: Function;
                toBits: Function;
            };
            hex: {
                fromBits: Function;
                toBits: Function;
            };
            utf8String: {
                fromBits: Function;
                toBits: Function;
            };
        };
        function decrypt(a: any, b: any, c: any, d: any): any;
        function encrypt(a: any, b: any, c: any, d: any, ...args: any[]): any;
        namespace exception {
            class bug {
                constructor(a: any);
                toString: any;
                message: any;
            }
            class corrupt {
                constructor(a: any);
                toString: any;
                message: any;
            }
            class invalid {
                constructor(a: any);
                toString: any;
                message: any;
            }
            class notReady {
                constructor(a: any);
                toString: any;
                message: any;
            }
        }
        namespace hash {
            class sha256 {
                static hash(a: any): any;
                constructor(a: any);
                r: any;
                o: any;
                h: any;
                D(): void;
                finalize(): any;
                reset(): any;
                update(a: any): any;
            }
        }
        namespace json {
            function X(a: any, b: any, c: any, d: any): any;
            function Y(a: any, b: any, c: any, d: any): any;
            function decode(a: any): any;
            function decrypt(a: any, b: any, c: any, d: any): any;
            const defaults: {
                adata: string;
                cipher: string;
                iter: number;
                ks: number;
                mode: string;
                ts: number;
                v: number;
            };
            function e(a: any, b: any, c: any): any;
            function ea(a: any, b: any): any;
            function encode(a: any): any;
            function encrypt(a: any, b: any, c: any, d: any, ...args: any[]): any;
            function fa(a: any, b: any): any;
        }
        const keyexchange: {};
        namespace misc {
            const ca: {};
            function cachedPbkdf2(a: any, b: any): any;
            class hmac {
                constructor(a: any, b: any);
                M: any;
                n: any;
                G: any;
                digest(): any;
                encrypt(a: any): any;
                mac(a: any): any;
                reset(): void;
                update(a: any): void;
            }
            function pbkdf2(a: any, b: any, c: any, d: any, e: any): any;
        }
        const mode: {
            ccm: {
                L: Function;
                decrypt: Function;
                encrypt: Function;
                name: string;
                p: Function;
            };
            gcm: {
                Z: Function;
                decrypt: Function;
                encrypt: Function;
                g: Function;
                name: string;
                p: Function;
            };
            ocb2: {
                H: Function;
                decrypt: Function;
                encrypt: Function;
                name: string;
                pmac: Function;
            };
        };
        class prng {
            constructor(a: any);
            c: any;
            i: any;
            F: any;
            s: any;
            C: any;
            K: any;
            O: any;
            d: any;
            j: any;
            W: any;
            b: any;
            f: any;
            A: any;
            B: any;
            q: any;
            w: any;
            m: any;
            V: any;
            t: any;
            u: any;
            S: any;
            I: any;
            T: any;
            R: any;
            $(): void;
            U(a: any): void;
            aa(): void;
            addEntropy(a: any, b: any, c: any): void;
            addEventListener(a: any, b: any): void;
            ba(a: any): void;
            da(a: any): void;
            getProgress(a: any): any;
            isReady(a: any): any;
            randomWords(a: any, b: any): any;
            removeEventListener(a: any, b: any): void;
            setDefaultParanoia(a: any, b: any): void;
            startCollectors(): void;
            stopCollectors(): void;
        }
        const random: {
            $: Function;
            A: any;
            B: number;
            C: number;
            F: number;
            I: number[];
            K: {
                "crypto['randomBytes']": number;
            };
            O: number;
            R: number;
            S: number;
            T: number;
            U: Function;
            V: number;
            W: number;
            aa: Function;
            addEntropy: Function;
            addEventListener: Function;
            b: number[];
            ba: Function;
            c: {
                D: any;
                N: any;
                b: any;
                blockSize: any;
                finalize: any;
                h: any;
                o: any;
                r: any;
                reset: any;
                update: any;
            }[];
            d: number;
            da: Function;
            f: number[];
            getProgress: Function;
            i: number[];
            isReady: Function;
            j: number;
            m: number;
            q: boolean;
            randomWords: Function;
            removeEventListener: Function;
            s: {
                "crypto['randomBytes']": number;
            };
            setDefaultParanoia: Function;
            startCollectors: Function;
            stopCollectors: Function;
            t: number;
            u: number;
            w: {
                progress: {};
                seeded: {};
            };
        };
    }
}
